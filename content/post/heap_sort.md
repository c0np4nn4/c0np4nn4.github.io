+++
title = "Heap Sort"
description = "Sorting"
date = 2023-03-21
toc = true

[taxonomies]
categories = ["Lect", "Algorithm"]
tags = ["Sorting", "Algorithm"]

[extra]
math=true
+++

---

# Heap Sort
- 힙 정렬은 `Heap` 자료구조를 이용해 정렬하는 방법입니다.

## Heap
- `Heap` 은 `Complete Binary Tree` 형태의 자료구조 입니다.
- `Heap` 은 *Parent* 가 <u>항상</u> *Child* 보다 <u>크거나 작은</u> 성질을 갖습니다.
- 즉, 그림으로 나타내면 아래와 같습니다.

```
      2
     / \
    /   \
   /     \
  3       5
 / \     / \
4   6   7   8

```

- 위 그림은 `min-Heap` 으로, 부모의 값이 자식의 값보다 **작은** 경우입니다.

## Example
- 정렬은 *Root* 노드의 값이 정렬된 값임을 이용합니다.
- 위 그림에서 가장 작은 값인 숫자 $2$ 를 *pop* 하면 아래와 같이 될겁니다.
- pop 한 수는 오른쪽의 배열에 저장한다고 생각하겠습니다.

```
       
     / \
    /   \
   /     \           -----------------------------
  3       5          | 2 |   |   |   |   |   |   |
 / \     / \         -----------------------------
4   6   7   8

```

- 그럼 `Complete Binary Tree` 가 아니므로, 다시 `Heap` 구조로 재구성할 필요가 있습니다.
- 재구성한 결과는 아래와 같습니다.

```
      3
     / \
    /   \
   /     \           -----------------------------
  5       4          | 2 |   |   |   |   |   |   |
 / \     /           -----------------------------
6   7   8
```

- 그럼 다음으로 작은 수인 $3$ 을 얻어낼 수 있습니다.

```
      
     / \
    /   \
   /     \           -----------------------------
  5       4          | 2 | 3 |   |   |   |   |   |
 / \     /           -----------------------------
6   7   8
```

- 재귀적으로, 정렬을 모두 마치고 나면 아래와 같이 정렬된 수열을 얻을 수 있습니다.

```
                     -----------------------------
                     | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
                     -----------------------------
```

- 따라서, `Heap` 이 텅 빌 때까지 아래 두 과정을 반복하며 정렬 할 수 있습니다.
  - `Heap` 구조로 재구성합니다. (이를 *heapify* 라 부르기도 합니다)
  - *Root* 값을 *pop* 하고 Sorted 공간에 저장합니다.

---

