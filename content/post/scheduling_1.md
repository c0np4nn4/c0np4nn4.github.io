+++
title = "Scheduling (1)"
description = "Introduction of Scheduling"
date = 2023-03-22

[taxonomies]
categories = ["Lect", "OS"]
tags = ["Operating System", "OS", "Virtualization"]

[extra]
math=true
+++

---

# CPU Scheduling
- <mark>CPU Scheduling</mark> 이란 실행되기를 기다리며 `Queue` 에 들어가 있는 `Process` 들이 있을 때,
어떤 `Process` 를 실행할 것인지 결정하는 <mark>Policy</mark> 를 의미합니다.

## Scheduling Types
- <mark>Scheduler</mark> 의 성격에 따라 아래 두 종류를 생각할 수 있습니다.
  - ***Non-preemptive*** Scheduling
    - *Process* 가 <u>협조적</u>으로, CPU 를 내놓습니다.
  - ***Preemptive*** Scheduling
    - *Scheduler* 가 *Process* 의 동작을 통제할 수 있습니다.

## Five Assumptions
- 아래 다섯 가지 조건을 토대로, `이상적인 상황`을 가정해 볼 수 있습니다.
  - 각각의 작업(*process*) 들은 <mark>수행 시간이 동일</mark> 합니다.
  - 모든 작업들은 <mark>같은 시간에 도착하여 시작</mark>됩니다.
  - 작업이 한번 시작되면 <mark>완료할 때까지 쭉 수행</mark>됩니다.
  - 모든 작업은 <mark>CPU 만을 사용</mark>합니다.
  - 각 작업의 <mark>전체 수행 시간을 이미 알고</mark> 있습니다.
- 아래에서는 이러한 `이상적인 상황` 으로부터 `현실적인 상황` 으로 개념을 발전시킵니다.

## Scheduling Metrics
- <mark>Scheduling</mark> 의 성능을 평가하는 지표는 아래 세 종류가 있습니다.
  - `Turnaround time`
    - 작업(*process*)이 도착(*arrival*)한 다음 완료(*completion*)될 때까지 걸리는 시간입니다.
    $$T_{\text{turnaround}} = T_{completion} - T_{arrival}$$
  - `Response Time`
    - 작업이 도착한 후 첫 번째로 작업(*first run*)을 시작할 때까지 걸리는 시간입니다.
    $$T_{\text{response}} = T_{firstrun} - T_{arrival}$$
  - `Fairness`
    - 작업들이 얼마나 공평하게 수행되는지에 대한 지표입니다.

---

# FIFO
- 아주 직관적이고 간단한 방법으로, `FIFO` 를 생각해 볼 수 있습니다.
- 작업이 끝날 때까지 기다려야 하므로, ***Non-preemptive*** 입니다.
- 모든 작업이 줄을 서고 있으면, 언젠가는 **CPU** 를 할당받습니다.
  - 즉, <mark>Fairness</mark> 는 좋습니다.
- 이해를 돕기 위해 $A, B, C$ 세 작업이 `Scheduling` 을 위한 `Queue` 에 들어왔다고 가정하겠습니다.

```
+---+---+---+
|   |   |   |
|   |   |   |
| A | B | C |
|   |   |   |
|   |   |   |
+---+---+---+
+---+---+---+-----------
0   10  20  30
```

- 위에서 정한 가정 중 <mark>도착 시간</mark>이 같다는 조건이 있지만, 아주 간발의 차로 $A$, $B$, 그리고 $C$ 의 순서가 정해진다고 보면 되겠습니다.
- 이 때의 <mark>평균 turnaround time</mark> 을 구해보면 아래와 같습니다.
$$\textbf{Avg.}\text{turnaround time} = \frac{(10 - 0) + (20 - 0) + (30 - 0)}{3} = 20 \text{ secs}$$

## No more FIFO, Convoy effect
- `FIFO` 가 꽤 괜찮은 방법처럼 보이지만, 가정한 <mark>조건 1</mark>번을 제외하면 상황이 달라집니다.
  - <mark>조건 1번</mark> : 각 작업은 모두 <mark>수행 시간이 동일</mark>합니다.
- 예를 들어, $A$ 의 수행시간이 `100 secs` 라고 해보겠습니다.

```
+----------------------------+---+---+
|                            |   |   |
|                            |   |   |
|             A              | B | C |
|                            |   |   |
|                            |   |   |
+----------------------------+---+---+
+----------------------------+---+---+---------
0                            100 110 120
```
- 이 때의 <mark>평균 turnaround time</mark> 은 아래와 같습니다.
$$\textbf{Avg.}\text{turnaround time} = \frac{(100 - 0) + (110 - 0) + (120 - 0)}{3} = 110 \text{ secs}$$
- $A$ 가 긴 시간을 잡아먹기 때문에, 상대적으로 수행 시간이 짧은 $B$, $C$ 가 <u>불필요한 기다림</u>을 경험해야 합니다.
- 이 때, 작업의 순서를 바꾸더라도 <mark>최종 완료 시간은 동일</mark>하다는 점에 주목할 필요가 있습니다.
- 따라서, 최적화를 위해서는 `수행시간이 짧은 것부터 작업하도록 하는` 방식을 택할 수 있습니다.

---
# SJF (Shortest Job First)
- 첫 번째 가정인 <mark>수행시간이 모두 동일하다</mark>를 풀겠습니다.
- 아직 <mark>작업이 끝날 때까지 수행된다.</mark> 는 가정은 유효하므로 `Non-preemptive Schedule` 입니다.
- `SJF` 를 적용하면 아래와 같이 그래프가 변합니다.

```
+---+---+----------------------------+
|   |   |                            |
|   |   |                            |
| B | C |             A              |
|   |   |                            |
|   |   |                            |
+---+---+----------------------------+
+----------------------------+---+---+---------
0   10  20                   100 110 120
```
- 따라서, <mark>평균 turnaround time</mark> 은 아래와 같이 변합니다.
$$\textbf{Avg.}\text{turnaround time} = \frac{(10 - 0) + (20 - 0) + (120 - 0)}{3} = 50 \text{ secs}$$

## No more SJF, Late Arrivals
- 이제 두 번째 가정인 <mark>모든 작업은 같은 시각에 도착한다</mark> 를 풀겠습니다.
- 그럼, 수행시간이 긴 <mark>A</mark> 가 수행되는 중에 <mark>B</mark>, <mark>C</mark> 가 도착할 수도 있습니다.
- 예를 들어, <mark>B</mark>, <mark>C</mark> 가 <u>10 초</u> 에 도착했다고 해보겠습니다.
- 그래프는 아래와 같이 나타나게 됩니다.

```
     B, C
+----------------------------+---+---+
|     |                      |   |   |
|     .                      |   |   |
|     |       A              | B | C |
|     .                      |   |   |
|     |                      |   |   |
+----------------------------+---+---+
+----------------------------+---+---+---------
0     10                     100 110 120
```
- 그리고,  <mark>평균 turnaround time</mark> 은 아래와 같습니다.
$$\textbf{Avg.}\text{turnaround time} = \frac{(100 - 0) + (110 - 10) + (120 - 10)}{3} = 103.3 \text{ secs}$$
- 일단 작업시간이 긴 <mark>A</mark> 가 시작되면 수행이 끝날 때까지 기다려야만 합니다.
- 이는 `SJF` 가 `Non-preemptive` 이기 때문입니다.

---

# STCF (Shortest Time-to-Completion First)
- 이제 `Preemptive Scheduler` 의 개념을 적용합니다.
- 즉, 세 번째 가정인 <mark>한 번 작업이 수행되면 끝날 때까지 이어진다</mark> 가 해제됩니다.
- 새로운 작업이 들어오면 <u>남은 수행시간</u>이 더 짧은 쪽을 선택합니다.
- 예를 들어, 수행시간이 <u>100 초</u>인 <mark>A</mark> 가 수행되다가, 10초 에 <mark>B</mark>, <mark>C</mark> 가 도착했다고 가정하겟습니다.

```
   B, C
+-------------------------
|   |                     
|   .                     
| A |                    
|   .                     
|   |                     
+-------------------------
+----------------------------------------------
0   10                       
```
- <mark>B</mark>, <mark>C</mark> 는 각각 수행시간이 <u>10 초</u> 라고 두겠습니다.
- <mark>A</mark> 는 남은 수행시간이 <u>90 초</u> 이고, <mark>B</mark>, <mark>C</mark> 는 <u>10 초</u> 이므로 *남은 수행시간* 이 더 짧은 <mark>B</mark>, <mark>C</mark> 중 하나를 먼저 수행합니다.

```
+---+---+----------
|   |   |          
|   |   |          
| A | B |          
|   |   |          
|   |   |          
+---+---+----------
+----------------------------------------------
0   10  20                  
```
- <mark>A</mark> 는 여전히 남은 수행시간이 <u>90 초</u> 이고,  <mark>C</mark> 는 <u>10 초</u> 이므로 *남은 수행시간* 이 더 짧은 <mark>C</mark> 를 먼저 수행합니다.

```
+---+---+---+----------
|   |   |   |          
|   |   |   |          
| A | B | C |          
|   |   |   |          
|   |   |   |          
+---+---+---+----------
+----------------------------------------------
0   10  20  30                
```

- 그 후, 남은 <mark>A</mark> 를 전부 수행합니다.

```
+---+---+---+--------------------------+
|   |   |   |                          |
|   |   |   |                          |
| A | B | C |           A              |
|   |   |   |                          |
|   |   |   |                          |
+---+---+---+--------------------------+
+----------------------------------------------
0   10  20  30                         120
```
- 이 때의  <mark>평균 turnaround time</mark> 은 아래와 같습니다.
$$\textbf{Avg.}\text{turnaround time} = \frac{(120 - 0) + (20 - 10) + (30 - 10)}{3} = 50 \text{ secs}$$

## Problem
- 예를 들어, 수행시간이 <u>1000 초</u> 인 <mark>A</mark> 와 수행시간이 <u>1 초</u> 인 <mark>B</mark> 가 동시에 시작된다고 합시다.
- `STCF` 에 따르면, <mark>B</mark> 가 일단 수행됩니다.
- ***그런데***, 새로운 작업인 <mark>C</mark> 가 0.9 초 쯤에 들어왔다고 합시다.
- 만약 <mark>C</mark> 의 수행시간이 또 <u>1 초</u> 라고 한다면, <mark>A</mark> 는 또 후순위로 밀려나게 됩니다.
- 요약하면, `수행시간이 긴 작업은 CPU를 획득하기 힘들다` 는 문제가 있습니다.

---

# RR (Round-Robin)
- `STCF` 의 문제에 대해, 각 작업마다 <u>일정한 시간 제한</u>을 두는 방법을 생각할 수 있습니다.
- 각 작업을 `Run Queue`에 넣어두고, `Time Slice` 라 부르는 시간 단위만큼만 수행한 뒤 다시 `Queue` 에 넣는 방식입니다.
  - `Queue` 는 <mark>FIFO Queue</mark> 와 같이 생각하면 됩니다.
- 이런 식으로 작업하면, 모두 `Fair` 하게 수행할 수는 있곘지만 모든 작업의 <u>완료시간</u>이 뒤로 밀리는 만큼 전체 퍼포먼스는 떨어지게 됩니다.
- 예를 들어, <mark>A</mark>, <mark>B</mark>, <mark>C</mark> 가 모두 <u>10 초</u>의 작업시간을 가진다고 가정하겠습니다.
- `STCF` 까지는 아래와 같은 그래프를 그립니다.

```
+-----------+-----------+-----------+
|           |           |           |
|           |           |           |
|     A     |     B     |     C     |
|           |           |           |
|           |           |           |
+-----------+-----------+-----------+
+---------------------------------------
0           10          20          30
```
- 만약 `RR`이고, `Time Slice` 가 <u>5 초</u> 라 하면 아래와 같이 그래프가 변합니다.

```
+-----+-----+-----+-----+-----+-----+
|     |     |     |     |     |     |
|     |     |     |     |     |     |
|  A  |  B  |  C  |  A  |  B  |  c  |
|     |     |     |     |     |     |
|     |     |     |     |     |     |
+-----+-----+-----+-----+-----+-----+
+-----+---------------------------------
0     5     10    15    20    25    30
```

- <mark>평균 turnaround time</mark> 는 각각 아래와 같습니다.
$$\textbf{Avg.}\text{turnaround time 1} = \frac{(30 - 0) + (20 - 0) + (10 - 0)}{3} = 20 \text{ secs}$$
$$\textbf{Avg.}\text{turnaround time 2} = \frac{(20 - 0) + (25 - 0) + (30 - 0)}{3} = 25 \text{ secs}$$
- 따라서, 전체적인 퍼포먼스는 낮아졌음을 알 수 있습니다.
- 하지만, <mark>평균 Response time</mark> 은 아래와 같이 좋아짐을 알 수 있습니다.
$$\textbf{Avg.}\text{response time 1} = \frac{0 + 10 + 20}{3} = 10 \text{ secs}$$
$$\textbf{Avg.}\text{response time 2} = \frac{0 + 5 + 10}{3} = 5 \text{ secs}$$
- 즉, 두 Metrics 는 *trade-off* 관계에 있음을 알 수 있습니다.
- 현대 컴퓨터 시스템에서는 '반응속도' 등 *UX* 도 중요하기 때문에, 퍼포먼스를 조금 손해보더라도 <mark>Response Time</mark> 을 향상하는 것이 중요할 수 있습니다.

## Time Slice
- `Time Slice` 에 관해 정리해 보겠습니다.
- ***Short*** `Time Slice`
  - <mark>Response Time</mark> 이 향상됩니다.
  - <mark>Context Switch</mark> 가 더 자주 발생하여, 전체 퍼포먼스는 떨어지게 됩니다.
- ***Long*** `Time Slice`
  - <mark>Response Time</mark> 은 나빠집니다.
  - <mark>Context Switch</mark> 에 대한 cost 는 줄어듭니다.

---
# I/O
- 이제 네 번쨰 가정인 <mark>작업은 CPU 만을 이용한다</mark> 를 해제하겠습니다.
- 예를 들어, <mark>A</mark>, <mark>B</mark> 가 둘 다 <u>20초</u> 의 수행시간을 갖는다고 해봅시다.
- 스케쥴링은 `RR`을 이용하며, `Time Slice` 는 <u>10 초</u> 라 하겠습니다.
- 만약 <mark>A</mark> 가 10 초의 작업 후 `I/O` 작업을 한다고 하면, <mark>B</mark>(20 초) 보다 <mark>A</mark>(10 초) 의 "***남은 수행시간***" 이 짧으므로 `I/O` 작업 중 <mark>B</mark> 가 작업 수행을 시작할 수 없습니다.
- 그래프로 나타내면 아래와 같습니다.

```
      +-----+     +-----+     +-----+-----+
 CPU  |  A  |     |  A  |     |  B  |  B  |
      +-----+-----+-----+-----+-----+-----+
 DISK       | I/O |     | I/O |                   
            +-----+     +-----+
      +-----+---------------------------------
      0     10    20    30    40    50    60
```
- 만약 `I/O` 가 일어날 때, `Ready Queue` 에 들어가는 것을 아예 막아버리면 아래와 같이 그래프가 변합니다.

```
      +-----+-----+-----+-----+            
 CPU  |  A  |  B  |  A  |  B  |            
      +-----+-----+-----+-----+            
 DISK       | I/O |     | I/O |                   
            +-----+     +-----+
      +-----+---------------------------------
      0     10    20    30    40    50    60
```
- 정리하면, `I/O` 가 일어날 때는 `I/O` 작업이 끝날 때까지 `Block` 시킵니다.
- 그리고, CPU 는 다른 작업을 수행하도록 스케쥴해야 합니다.
- `I/O` 가 끝나면, 다시 `Ready Queue` 로 보내지게 됩니다.

---

- 이제 마지막 가정인 <mark>수행 시간을 모두 알고 있다</mark>를 해제할 차례입니다.
- 이는 다음 포스트에 이어서 정리하도록 하겠습니다.
