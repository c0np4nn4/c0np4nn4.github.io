+++
title = "Scheduling (2)"
description = "CPU Virtualization (2)"
date = 2023-03-26

[taxonomies]
categories = ["Lect", "OS"]
tags = ["Operating System", "OS", "Virtualization"]

[extra]
math=true
+++

---

- 스케쥴링에 관한 앞선 [포스트](@/post/scheduling_1.md)에서, 아래의 가정을 푸는 것이 마지막 일이라 했습니다.
  - **가정 5**: <mark>작업의 수행시간을 모두 알고 있다</mark>
- 이는 작업의 ***특성*** 을 알고 있다는 말로 이어지는데, `interactive` 가 중요한 작업인지 `performace` 가 중요한 작업인지를 의미합니다.
- 작업에 대해 알 수 있는 가장 직관적인 방법은 일단 수행시킨 뒤 특성을 분석하는 방법입니다. (*Learn from the past*)

---

# MLFQ (Multi-Level Feedback Queue)
- 이전 포스트에서 보았듯이, 각 작업은 `Run Queue` 에 저장되어 스케줄링을 기다립니다.
- 이번에는 그 `Queue` 에 높낮이를 부여합니다.

```
+--------------+
|              |  +---+  +---+  +---+
|  Priority 3  |--|   |--|   |--|   |
|              |  +---+  +---+  +---+
+--------------+
|              |  +---+
|  Priority 2  |--|   |
|              |  +---+
+--------------+
|              |  +---+  +---+  +---+  +---+
|  Priority 1  |--|   |--|   |--|   |--|   |
|              |  +---+  +---+  +---+  +---+
+--------------+
```
- 작업은 아래 규칙에 따라 처리됩니다.
> - *Priority* 가 높은 `Queue` 의 작업들을 우선적으로 처리합니다.
> - 같은 `Queue` 의 작업들은 `RR` 방식의 스케줄링으로 처리합니다.
- 작업의 *Priority* 는 작업의 ***특성*** 을 기반으로 결정됩니다.
- 이 ***특성*** 은 작업의 <u>수행패턴</u> 을 토대로 결정됩니다.

## Job Type
- 작업은 아래와 같이 크게 두 종류로 분류할 수 있습니다.
  - `Interactive Job`
    - <mark>Response Time</mark> 이 중요합니다.
    - 따라서, *높은 Priority* 를 가져야 합니다.
  - `CPU-Intensive Job (Performace)`
    - 오랜 시간동안, CPU 를 점유하여 작업해야 합니다.
    - 따라서, 높은 *Priority* 를 갖고 있을 필요는 없습니다.

## How to change Priority
- 처음 들어온 작업은 `가장 높은 우선순위`를 받습니다.
- `Time Slice` 를 모두 사용한 작업은 <mark>우선순위를 하나 내립니다.</mark>
- `Time Slice` 를 모두 사용하지 않고, CPU 를 돌려준 작업은 <mark>우선순위를 유지</mark>합니다.

## Example

### 1) Long running job
- 작업 <mark>A</mark> 의 수행시간이 <u>80 초</u> 이고, `Time Slice` 가 <u>10 초</u> 일 때 아래와 같이 그래프가 그려집니다.

```
         +---+        
         |   |        
  Q2     | A |        
         |   |        
         +---+---+        
         .   |   |    
  Q1         | A |    
         .   |   |    
             +---+-----------+
         .   .   |           |
  Q0             |     A     |
         .   .   |           |
         +---+---+-----------+
         +---+---+-----------+---
         0   10  20          80
```

### 2) Interrupted by a short runnig job
- 만약 수행시간이 <u>30 초</u> 인 작업 <mark>B</mark> 가 *40 초* 에 들어왔다고 해보겠습니다.
- 그럼 그래프는 아래와 같이 변합니다.

```
         +---+           +---+                   
         |   |           |   |
  Q2     | A |           | B |  
         |   |           |   |  
         +---+---+       +---+---+                          
         .   |   |       .   |   |
  Q1         | A |           | B |
         .   |   |       .   |   |
             +---+-------+   +---+---+---+-------+
         .   .   |       |   .   |   |   |       | 
  Q0             |   A   |       | A | B |   A   | 
         .   .   |       |       |   |   |       | 
         +---+---+-------+   .   +---+---+-------+   
         +---+---+-------+---+---+---+---+-------+-----------
         0   10  20      40  50  60  70  80      110
```
- <mark>B</mark> 는 처음 들어왔으므로, `가장 높은 우선순위` 를 받습니다.
- 이후 `Q_0 Queue` 까지 내려오면, <mark>A</mark>와 함께 순차적으로 수행됩니다.

### 3) I/O
- 아래 두 작업이 있다고 가정해보겠습니다.
  - <mark>A</mark>: `Interactive Job` 으로, `CPU` 를 *1 초* 만 쓰고, `I/O` 작업을 합니다.
  - <mark>B</mark>: `CPU-Intensive Job` 으로, 수행시간이 깁니다.
- 이 두 작업이 그리는 그래프는 아래와 같습니다.

```
         +-+     +-+     +-+     +-+     +-+                         
         | |     | |     | |     | |     | |       
  Q2     |A|     |A|     |A|     |A|     |A|        
         | |     | |     | |     | |     | |        
         +-+     +-+     +-+     +-+     +-+                                    
         . .     . .     . .     . .     . .       
  Q1     . .     . .     . .     . .     . .       
         . .     . .     . .     . .     . .       
         . +-----+ +-----+ +-----+ +-----+ +-----+           
         . |     | |     | |     | |     | |     |            
  Q0     . |  B  | |  B  | |  B  | |  B  | |  B  |            
         . |     | |     | |     | |     | |     |            
         . +-----+ +-----+ +-----+ +-----+ +-----+                  
         +-+-----+-+-----+-+-----+-+-----+-+-----------------
```

- <mark>A</mark> 는 작업이 다 끝나지 않고, `I/O` 로 인해 `Block` 이 되므로 다시 `Run Queue` 에 들어오면 가장 높은 우선순위를 부여받습니다.
- 자연스레 아래의 ***두 문제***를 생각해볼 수 있습니다.
> - 만약 `Interactive Job` 이 ***엄청나게 많아지면***, <mark>B</mark> 는 `CPU` 를 획득하기 어려워집니다.
> - 만약 <mark>A</mark> 가 ***99%*** 의 작업 수행 후 `I/O` 를 하면, `CPU` 를 최우선적으로 획득할 수 있습니다.

# Priority Boost
- 일정 시간 $S$ 가 지난 뒤에는 <u>작업의 종류와 상관없이</u> 최우선 큐로 우선순위를 올려주는 기법입니다.
- 즉, 주기적으로 `최우선 큐`에 작업을 올려주는 기법입니다. 
- 이를 통해 첫 번쨰 문제인 `Starvation Problem` 을 해결할 수 있습니다.

# Better Accounting
- 작업이 일정 시간 $S$ 중 얼마만큼을 사용했는지 항상 기억하고 있습니다.
- 이를 통해, `I/O` 등이 일어나도 할당받은 시간만큼만 사용하도록 할 수 있습니다.
- 여기에, $S$ 가 지나면 우선순위를 하나 내리는 방법을 사용합니다.
- 이를 통해 두 번째 문제인 `Gaming of scheduler` 를 해결할 수 있습니다.
- 그래프로 나타내면 대략 아래와 같습니다.

```
         +---+ +-+                                                        
         |   | | |                                      
  Q2     | A | |A|                                       
         |   | | |                                       
         +---+ +-+ +---+ +-+                                                                  
         .   . . . |   | | |                                
  Q1     .   . . . | A | |A|                                
         .   . . . |   | | |                                
         .   . . . +---+ +-+                                          
         .   . . . .   . . .                                  
  Q0     .   . . . .   . . .                                  
         .   . . . .   . . .                                  
         .   . . . .   . . .                                        
         +---+-+-+-+---+-+-+---------------------------------
```
- <mark>A</mark> 의 사이는 `I/O` 로 인해 발생합니다.
- 이전에는 `I/O` 이후 `CPU` 를 계속 같은 레벨의 `큐` 에서 사용했지만, 여기서는 우선순위가 하나 내려갑니다.

# Tuning MLFQ
- 아래와 같이 `MLFQ` 를 수정할 수 있습니다.
  - 우선순위가 <u>높을수록</u>, `Time Slice`를 <u>짧게</u> 줍니다.
  - 우선순위가 <u>낮을수록</u>, `Time Slice`를 <u>길게</u> 줍니다.
