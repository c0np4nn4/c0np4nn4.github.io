+++
title = "Scheduling (2)"
description = "Introduction of Scheduling"
date = 2023-03-26

[taxonomies]
categories = ["Lect", "OS"]
tags = ["Operating System", "OS", "Virtualization"]

[extra]
math=true
+++

---

- 스케쥴링에 관한 앞선 [포스트](@/post/scheduling_1.md)에서, 아래의 가정을 푸는 것이 마지막 일이라 했습니다.
  - **가정 5**: <mark>작업의 수행시간을 모두 알고 있다</mark>
- 이는 작업의 ***특성*** 을 알고 있다는 말로 이어지는데, `interactive` 가 중요한 작업인지 `performace` 가 중요한 작업인지를 의미합니다.
- 작업에 대해 알 수 있는 가장 직관적인 방법은 일단 수행시킨 뒤 특성을 분석하는 방법입니다. (*Learn from the past*)

---

# MLFQ (Multi-Level Feedback Queue)
- 이전 포스트에서 보았듯이, 각 작업은 `Run Queue` 에 저장되어 스케줄링을 기다립니다.
- 이번에는 그 `Queue` 에 높낮이를 부여합니다.

```
+--------------+
|              |  +---+  +---+  +---+
|  Priority 3  |--|   |--|   |--|   |
|              |  +---+  +---+  +---+
+--------------+
|              |  +---+
|  Priority 2  |--|   |
|              |  +---+
+--------------+
|              |  +---+  +---+  +---+  +---+
|  Priority 1  |--|   |--|   |--|   |--|   |
|              |  +---+  +---+  +---+  +---+
+--------------+
```
- 작업은 아래 규칙에 따라 처리됩니다.
> - *Priority* 가 높은 `Queue` 의 작업들을 우선적으로 처리합니다.
> - 같은 `Queue` 의 작업들은 `RR` 방식의 스케줄링으로 처리합니다.
- 작업의 *Priority* 는 작업의 ***특성*** 을 기반으로 결정됩니다.
- 이 ***특성*** 은 작업의 <u>수행패턴</u> 을 토대로 결정됩니다.

## Job Type
- 작업은 아래와 같이 크게 두 종류로 분류할 수 있습니다.
  - `Interactive Job`
    - <mark>Response Time</mark> 이 중요합니다.
    - 따라서, *높은 Priority* 를 가져야 합니다.
  - `CPU-Intensive Job (Performace)`
    - 오랜 시간동안, CPU 를 점유하여 작업해야 합니다.
    - 따라서, 높은 *Priority* 를 갖고 있을 필요는 없습니다.

## How to change Priority
- 처음 들어온 작업은 `가장 높은 우선순위`를 받습니다.
- `Time Slice` 를 모두 사용한 작업은 <mark>우선순위를 하나 내립니다.</mark>
- `Time Slice` 를 모두 사용하지 않고, CPU 를 돌려준 작업은 <mark>우선순위를 유지</mark>합니다.

## Example

### 1) Long running job
- 작업 <mark>A</mark> 의 수행시간이 <u>80 초</u> 이고, `Time Slice` 가 <u>10 초</u> 일 때 아래와 같이 그래프가 그려집니다.

```
         +---+        
         |   |        
  Q2     | A |        
         |   |        
         +---+---+        
         .   |   |    
  Q1     .   | A |    
         .   |   |    
         ....+---+-----------+
         .   .   |           |
  Q0     .   .   |     A     |
         .   .   |           |
         +---+---+-----------+
         +---+---+-----------+---
         0   10  20          80
```

### 2) Interrupted by a short runnig job
- 만약 수행시간이 <u>30 초</u> 인 작업 <mark>B</mark> 가 *40 초* 에 들어왔다고 해보겠습니다.
- 그럼 그래프는 아래와 같이 변합니다.

```
         +---+           +---+                   
         |   |           |   |
  Q2     | A |           | B |  
         |   |           |   |  
         +---+---+       +---+---+                          
         .   |   |       .   |   |
  Q1     .   | A |       .   | B |
         .   |   |       .   |   |
         .   +---+-------+   +---+---+---+-------+
         .   .   |       |   .   |   |   |       | 
  Q0     .   .   |   A   |   .   | A | B |   A   | 
         .   .   |       |   .   |   |   |       | 
         +---+---+-------+   .   +---+---+-------+   
         +---+---+-------+---+---+---+---+-------+-----------
         0   10  20      40  50  60  70  80      110
```
- <mark>B</mark> 는 처음 들어왔으므로, `가장 높은 우선순위` 를 받습니다.
- 이후 `Q0 Queue` 까지 내려오면, <mark>A</mark>와 함께 순차적으로 수행됩니다.

### 3) I/O
