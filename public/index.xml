<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>🪴 c0np4nn4</title>
      <link>https://aurev01r.xyz</link>
      <description>최근 10 건 on 🪴 c0np4nn4</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>2.3 Polynomials over Galois Field GF(2)</title>
    <link>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.3-Polynomials-over-Galois-Field-GF(2)</link>
    <guid>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.3-Polynomials-over-Galois-Field-GF(2)</guid>
    <description></description>
    <pubDate>Tue, 05 Nov 2024 11:15:56 GMT</pubDate>
  </item><item>
    <title>2.2 Finite Fields</title>
    <link>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.2-Finite-Fields</link>
    <guid>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.2-Finite-Fields</guid>
    <description>2.1 Groups에서 살펴본 Group 개념을 기반으로 algebric coding theory 나 다음과 같은 error-correcting codes 를 구축하는데 기반이 되는 Field 개념을 살펴봅니다. Reed-Solomon Codes (RS codes) Bose-Chaudhuri-Hocquenghem codes (BCH codes) low-density parity-check codes (LDPC codes) 2.2.1 기본 정의 및 개념 Definition 정의 2.6] Field 원소의 집합 F 는 Group 에서 다뤘던 두 이항 연산 addition (+), multiplication (\cdot) 이 정의되었을 때, 아래 조건을 만족하면 Field 가 됩니다.</description>
    <pubDate>Tue, 05 Nov 2024 02:29:22 GMT</pubDate>
  </item><item>
    <title>2.1 Groups</title>
    <link>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.1-Groups</link>
    <guid>https://aurev01r.xyz/Cryptography/ECC-%EA%B8%B0%EC%B4%88/2.1-Groups</guid>
    <description>2.1.1 기본 정의 및 개념 원소의 집합 G가 있다고 해봅시다. 임의의 이항 연산(binary operation) * 를 규칙(rule)이라 부르고, 아래와 같이 c \in G 인 원소 c 를 고유하게(uniquely) 정의한다고 해보겠습니다. c = a * b 이러한 이항 연산 * 가 G에 대해 정의되어 있다면, G가 *에서 닫혀있다(closed)고 합니다.</description>
    <pubDate>Mon, 04 Nov 2024 08:31:13 GMT</pubDate>
  </item><item>
    <title>NEAR, FastAuth</title>
    <link>https://aurev01r.xyz/Notes/NEAR,-FastAuth</link>
    <guid>https://aurev01r.xyz/Notes/NEAR,-FastAuth</guid>
    <description></description>
    <pubDate>Thu, 24 Oct 2024 00:38:57 GMT</pubDate>
  </item><item>
    <title>Sui, DApp Frontend</title>
    <link>https://aurev01r.xyz/Notes/Sui,-DApp-Frontend</link>
    <guid>https://aurev01r.xyz/Notes/Sui,-DApp-Frontend</guid>
    <description>1. Example yarn create @mysten/dapp --template react-client-dapp # &lt;ENTER&gt; cd my-first-sui-dapp yarn yarn dev 지갑을 연결해볼 수 있는 예제 사이트가 나옵니다. 2. 코드 분석 2-1.</description>
    <pubDate>Thu, 10 Oct 2024 17:31:37 GMT</pubDate>
  </item><item>
    <title>Sui (로컬) DApp 개발 연습</title>
    <link>https://aurev01r.xyz/Notes/Sui-(%EB%A1%9C%EC%BB%AC)-DApp-%EA%B0%9C%EB%B0%9C-%EC%97%B0%EC%8A%B5</link>
    <guid>https://aurev01r.xyz/Notes/Sui-(%EB%A1%9C%EC%BB%AC)-DApp-%EA%B0%9C%EB%B0%9C-%EC%97%B0%EC%8A%B5</guid>
    <description>우선 아래와 같이 입력해 새로운 프로젝트를 생성합니다. sui move new my_frist_package 생성된 폴더인 my_first_package로 가보면 manifest file 인 Move.toml과 소스코드가 있는 sources 디렉토리가 있습니다. 1. Package 정의하기 sources/my_first_package.move 는 사실 아무런 기능을 하지 않습니다.</description>
    <pubDate>Thu, 10 Oct 2024 07:28:36 GMT</pubDate>
  </item><item>
    <title>Sui (로컬) 개발 환경 구축</title>
    <link>https://aurev01r.xyz/Notes/Sui-(%EB%A1%9C%EC%BB%AC)-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95</link>
    <guid>https://aurev01r.xyz/Notes/Sui-(%EB%A1%9C%EC%BB%AC)-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95</guid>
    <description>Docs 읽고 한글로 정리해두려고 합니다… TL;DR Tool, Sui 설치 Localnet 구동 sui start with options (faucet, regensis) Localnet &lt;&gt; CLI 연결 sui client &lt;env&gt; Localnet Account 생성 sui client &lt;address&gt; ...</description>
    <pubDate>Thu, 10 Oct 2024 05:27:53 GMT</pubDate>
  </item><item>
    <title>Ethernaut(0x03), Coin Flip</title>
    <link>https://aurev01r.xyz/Ethernaut/Ethernaut(0x03),-Coin-Flip</link>
    <guid>https://aurev01r.xyz/Ethernaut/Ethernaut(0x03),-Coin-Flip</guid>
    <description>Random인 척 하는 값을 이용한다고도 볼 수 있고. Random을 구현하기 힘듦을 나타내는 것이라고도 할 수 있고. 아무튼 그런 문제입니다. 초 심플한 문제입니다. flip() 함수 하나만 있는데, 플레이어가 할 일은 _guess 값을 제대로 넣는 것 밖에 없습니다. 솔직히 script 짜기 귀찮지만, 연습삼아 해보기로 했습니다.</description>
    <pubDate>Thu, 03 Oct 2024 19:56:18 GMT</pubDate>
  </item><item>
    <title>Ethernaut(0x02), Fal1out</title>
    <link>https://aurev01r.xyz/Ethernaut/Ethernaut(0x02),-Fal1out</link>
    <guid>https://aurev01r.xyz/Ethernaut/Ethernaut(0x02),-Fal1out</guid>
    <description>문제에 나와있듯이 ownership 을 획득하면 되는 문제입니다. 사실 코드를 좀 살펴보면, ***Factory.sol 에 풀이 완료 조건이 있긴 합니다. instance.owner() 와 현재 player 가 동일하다면 통과하는 로직입니다. owner 를 바꾸는 로직은 문제에서 /*constructor*/로 주석을 남긴 함수가 바로 보입니다.</description>
    <pubDate>Thu, 03 Oct 2024 19:45:49 GMT</pubDate>
  </item><item>
    <title>Ethernaut(0x01), Fallback</title>
    <link>https://aurev01r.xyz/Ethernaut/Ethernaut(0x01),-Fallback</link>
    <guid>https://aurev01r.xyz/Ethernaut/Ethernaut(0x01),-Fallback</guid>
    <description>소스코드부터 살펴보겠습니다. 이미지로 가져왔는데, 일일이 다 볼 필요는 없어서 그냥 전체 코드 양을 가늠하는 느낌으로 첨부해보았습니다. 사실 receive(), fallback() 함수가 어떤 것인지 살펴보면 되는 문제입니다. 코드는 함수 이름들에서 알 수 있듯이, 누구나 Ether를 기여(contribute)할 수 있고.</description>
    <pubDate>Thu, 03 Oct 2024 18:14:32 GMT</pubDate>
  </item>
    </channel>
  </rss>