{"CTF/Sekai2024":{"title":"Sekai2024 CTF","links":[],"tags":["CTF","Review"],"content":""},"Cryptography/Digital-Signature":{"title":"Digital Signature","links":["Cryptography/Hash-Function","Cryptography/Public-Key-Cryptography"],"tags":["Cryptography"],"content":"디지털 서명: 안전한 전자 문서의 보증\n디지털 세상이 점점 더 확장됨에 따라, 우리는 온라인에서 중요한 문서를 전송하거나 계약을 맺을 때 그 문서의 진위성을 보장받을 필요가 있습니다. 예를 들어, 누군가가 문서를 조작하지 않았다는 것을 어떻게 확신할 수 있을까요? 또는, 그 문서를 실제로 특정한 사람이 작성했음을 어떻게 증명할 수 있을까요? 바로 이때 등장하는 기술이 디지털 서명입니다. 이 글에서는 디지털 서명이 무엇인지, 어떻게 작동하는지, 그리고 일상에서 어떻게 사용되는지를 쉽게 설명해보겠습니다.\n\n1) 디지털 서명의 개념\n디지털 서명은 전자 문서나 메시지의 진위성과 무결성을 보장하는 일종의 전자 도장입니다. 일반적인 서명이 종이 위에 서명자의 손글씨로 이루어지듯, 디지털 서명은 전자적으로 이루어집니다. 디지털 서명은 두 가지 주요 기능을 수행합니다:\n\n진위성 확인: 문서가 실제로 특정 사람에 의해 작성되었음을 증명합니다.\n무결성 보장: 문서가 작성된 이후에 전혀 변경되지 않았음을 보장합니다.\n\n쉽게 말해, Alice가 문서에 남긴 디지털 서명은 아래의 내용을 확실히 보장합니다.\n\n“Alice가 문서를 작성 후 직접 서명을 남겼고, 이 문서의 내용은 전혀 변하지 않았다”\n\n\n2) 디지털 서명 생성 및 검증 과정\n이러한 디지털 서명이 어떻게 만들어지고 검증되는 것인지 알아보겠습니다.\n과정은 서명 생성과 서명 검증의 두 단계로 나뉩니다.\n서명 생성\n\n\n해시 함수 사용: 먼저, 작성된 문서의 내용을 고정된 길이의 데이터로 변환합니다. 이 과정에서 사용하는 것이 바로 해시 함수입니다. 해시 함수는 입력 데이터에 대해 매우 독특한 소위 “디지털 지문”을 만들어냅니다.\n\n\n개인 키로 암호화: 서명자는 이 해시 값을 자신의 개인 키를 사용하여 암호화합니다. 이 암호화된 해시 값이 바로 디지털 서명이 됩니다. 여기서 개인 키는 서명자만 알고 있는 비밀 키로, 외부에 유출되어서는 안 됩니다.\n\n\n서명 검증\n\n\n공개 키로 복호화: 문서를 받는 사람은 서명자의 공개 키를 사용하여 디지털 서명을 복호화합니다. 이때 공개 키는 누구나 볼 수 있으며, 이를 통해 서명자의 신원(진위성)을 확인할 수 있습니다.\n\n\n해시 값 비교: 문서의 내용을 같은 해시 함수로 다시 해싱하여 새로운 해시 값을 생성합니다. 이 해시 값이 복호화된 해시 값과 일치하면, 문서가 변조되지 않았음(무결성)을 확인할 수 있습니다.\n\n\n\n3) 디지털 서명의 동작 원리(수학적 원리)\n디지털 서명이 왜 안전한지 이해하려면, 수학적 원리를 간단히 살펴볼 필요가 있습니다. 이 부분에서는 복잡한 수학적 개념을 피하면서도 이해하기 쉽게 설명하겠습니다.\n해시 함수\n해시 함수는 입력 데이터를 고정된 길이의 “해시 값”으로 변환하는 함수입니다. 중요한 점은 아주 작은 입력의 변화도 완전히 다른 해시 값을 만들어낸다는 것입니다. 따라서 문서가 조금이라도 변경되면, 생성된 해시 값이 달라져서 문서가 변조되었음을 쉽게 알 수 있습니다.\n공개 키 암호화\n디지털 서명은 공개 키 암호화 기법을 사용합니다. 이는 두 개의 키, 즉 공개 키와 개인 키로 이루어져 있습니다. 개인 키로 암호화한 데이터는 오직 해당 개인 키에 상응하는 공개 키로만 복호화할 수 있습니다. 이는 수학적 난제를 이용하여 이루어지며, 예를 들어 RSA 알고리즘에서는 큰 소수를 곱한 결과로부터 원래 소수를 찾는 것이 매우 어렵다는 사실을 기반으로 합니다.\n이러한 수학적 기초 덕분에, 디지털 서명은 서명자가 아닌 다른 사람이 위조하거나 변경할 수 없습니다.\n\n4) 디지털 서명의 대표적인 예\n디지털 서명은 다양한 분야에서 사용되고 있으며, 그중 몇 가지 대표적인 예를 살펴보겠습니다.\n전자 계약\n기업 간 계약서나 법적 문서를 전자적으로 주고받을 때 디지털 서명이 사용됩니다. 이는 문서의 진위성을 보장하고, 추후에 문서가 변조되지 않았음을 증명할 수 있게 합니다.\n소프트웨어 배포\n소프트웨어 개발자는 자신이 만든 프로그램에 디지털 서명을 하여, 사용자에게 이 프로그램이 공식적으로 배포된 것이며 중간에 변조되지 않았음을 보장합니다. 예를 들어, 운영체제에서 설치 프로그램을 실행할 때 “이 프로그램이 신뢰할 수 있는 출처에서 왔는지”를 확인하는 과정에서 디지털 서명이 사용됩니다.\n전자 메일\n디지털 서명은 이메일을 전송할 때 사용되기도 합니다. 중요한 이메일에 디지털 서명을 첨부하면, 수신자는 이메일이 실제 발신자로부터 왔으며 내용이 변조되지 않았음을 확인할 수 있습니다.\n"},"Cryptography/Hash-Function":{"title":"Hash Function","links":[],"tags":["Cryptography","Algorithm"],"content":"(wip)"},"Cryptography/Public-Key-Cryptography":{"title":"Public Key Cryptography","links":[],"tags":["Cryptography","Mathematics","Algorithm"],"content":"(wip)"},"Data-Structure/bipartite-graph":{"title":"Bipartite Graph","links":[],"tags":["DataStructure"],"content":"(wip)"},"Notes/16AUG,-PSE-Core-Program":{"title":"Simple ZK Static Program Analysis","links":[],"tags":["PSE_Core_Program","ZKP","Hackathon"],"content":"들어가며\n8월 16일 금요일의 PSE Core Program off-line meet 시간에는 ZKP 를 활용한 미니 해커톤이 진행되었다.\n나는 Orion 논문을 읽다가 발견했던 흥미로운 주제인 ZK Static Program Analysis 로 미니 해커톤에 참가했다. 결과물로 구현하고자 하는 것은 아래와 같다.\n\n임의의 Rust 프로그램 소스코드에 division by zero를 일으킬 수 있는 코드가 없음을 ZKP로 증명 하는 프로그램\n\nZKP 프로젝트인만큼 원본 소스코드에 관해서는 zero-knowledge인 것이 특징이다.\n안전한 소스코드 임을 직접 제출할 필요 없이도 증명할 수 있는 것이다.\nParser와 Circuit은 아래와 같이 설게 및 구현되었다.\n\nParser: Rust 코드를 분석해 Circuit의 입력값으로 변환하는 단계\nCircuit: 분석된 Rust코드를 통해 정적 분석을 수행하는 단계\n\n구현물은 github.com/c0np4nn4/simple_zk_spa 에서 확인할 수 있다.\n\n구현 상세\n1. Parser\nParser는 Rust 문법으로 작성된 소스코드를 읽고 각 줄을 분석하여 아래 형태의 배열로 변환한다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n원소 1원소 2원소 3원소 4Op Type명령어 종류lhs elem좌항 원소rhs elem 1우항 원소 1rhs elem 2우항 원소 2\n아주 간단한 형태의 예시 프로그램 사용을 가정했기에 분석기도 매우 간결하게 구현하였다.\n명령어의 종류는 아래와 같이 총 4개로만 설계했다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n명령어 번호명령어 종류명령어 설명0NoOp프로그램 종료를 의미하는 동작 코드 모든 배열의 원소가 0 ([0, 0, 0, 0])1Assign좌항 원소에 우항 원소 1을 저장 이 때, 우항 원소 2는 무조건 02Addition좌항 원소에 우항 원소 1과 우항 원소 2의 덧셈 결과를 저장3Division좌항 원소에 우항 원소 1과 우항 원소 2의 나눗셈 결과를 저장\n또, 변수(variable)와 값(value)를 아래와 같이 구분했다.\n\n변수는 모두 홀수로 표기한다.\n값은 모두 2를 곱한 값으로 배열 원소에 저장한다.\n\n1-1. Example\n아래와 같은 예제 소스 코드 example.rs가 있다고 해보자.\nfn main() {\n\tlet x: i64 = 7;\n\tlet y: i64 = -7;\n\tlet z: i64 = x + y;\n\tlet a: i64 = 4 / z;\n}\n각각의 줄은 다음과 같이 해석된다.\n{\n\t[1, 1,  14, 0], # [  &#039;assign&#039;,  &#039;x&#039;,  7 * 2,  nil]\n\t[1, 3, -14, 0], # [  &#039;assign&#039;,  &#039;y&#039;, -7 * 2,  nil]\n\t[2, 5,   1, 3], # [&#039;addition&#039;,  &#039;z&#039;,    &#039;x&#039;,  &#039;y&#039;]\n\t[3, 7,   8, 5]  # [&#039;division&#039;,  &#039;a&#039;,  4 * 2,  &#039;z&#039;]\n}\n값에 해당하는 7, -7, 4 는 모두 2배 곱해져서 배열로 정리되어 있음을 확인할 수 있다.\n\n2. Circuit\nParser는 단순하게 구현만 하면 됐지만, Circuit에서는 정적분석의 방법을 정하고 이를 구현해야 했다.\n이에 관해 “정적 분석은 계산 안하기 하는 것이라 생각할 수 있다.” 라는 조언을 바탕으로 아래와 같이 분석 방법을 정했다.\n\n양수인 값은 +로 둔다.\n음수인 값은 -로 둔다.\n덧셈의 피연산자에 관해 아래 세 가지 경우로 나뉠 수 있다.\n\n(양수) + (양수) = 양수, 즉 + 가 된다.\n(음수) + (음수) = 음수, 즉 -가 된다.\n(양수) + (음수) = ??\n\n\n\n양수와 음수를 더한 경우 결과를 T라고 두었으며, 이는 \\{+, -, 0\\} 중 하나이다.\ndivision by zero 는 나눗셈의 제수(분모)가 0일 때 발생한다.\n하지만,정확한 계산 수행없이 에러 발생의 가능성을 분석하기 위해서는 ‘제수가 T 인지’를 검사하는 것으로 충분하다.\n만약 검사하는 코드가 우주선이나 비행기에 들어가는 코드라고 생각해보자.\ndivision by zero 에러로 인해 프로그램이 정지하거나 문제를 일으키는 경우, 우주비행사 또는 비행기 탑승객들의 생명에 직접적인 영향을 끼칠 수 있다.\n따라서, 실제로 에러가 발생할지 여부는 확실치 않더라도 가능성을 검출하는 것은 경우에 따라 대단히 중요해질 수 있음을 생각할 수 있다.\n2-1. 변수 값 저장\n홀수로 표시한 변수는 결국 어떠한 정보를 갖게 된다.\n정적 분석에서는 실제 계산이 없이 분석이 진행되야 하므로, Circuit 내에서는 아래와 같은 작업이 이뤄진다.\n\n값의 크기는 잊고 부호만 변수에 저장\n\n예를 들어, 아래와 같은 코드가 있다고 해보자.\nfn main() {\n\tlet p: i64 = +11;\n}\n이를 Parser를 통해 배열로 변환하면 아래와 같은 결과를 얻는다.\n{\n\t[1, 1, 22, 0] # [&#039;assign&#039;,  &#039;p&#039;,  11 * 2,  nil]\n}\n그리고 이를 Circuit 내부에서는 값의 크기인 11은 잊어버리고 그 부호인 +만 남긴다.\np = +\n2-2.  T 계산 과정\nT값은 덧셈연산을 통해 얻을 수 있다.\n따라서, Op Type이 Addition 인 경우에 rhs elem 1과 rhs elem 2의 부호정보를 확인하고 \\{+, -, T\\} 중 하나의 결과를 lhs elem에 저장하는 식으로 circuit을 구성했다.\n\n결과"},"Notes/PSE-Core-Group-Resources":{"title":"PSE Core Group Resources","links":[],"tags":["PSE_Core_Program","Cryptography"],"content":"2024년 PSE Core Group에서 활용한 자료들을 정리한 문서입니다.\nWeek 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTitleTagLinkKZG  articleKZG, PCSdankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.htmlKZG paperKZG, PCSwww.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf"},"PS/BOJ/📕(BOJ)2493":{"title":"📕(BOJ)2493","links":[],"tags":["Algorithm","PS"],"content":"문제\n[링크]\n\nN 개의 탑이 일렬로 나란히 서있는 모습을 상상해보자.\ni 번째 위치의 탑이 왼쪽을 향해 신호를 쏠 때, i 번째보다 높이가 높은 탑에서 신호를 수신한다고 한다.\n이 때, 각각의 i 번째 탑이 쏜 신호를 수신하는 탑의 번호를 모두 출력하는 문제이다.\n\n\n풀이\n\n\n이 문제에서는 시간초과를 해결하는 하나의 방법에 관한 아이디어를 익힐 수 있었다.\n\n\n처음에는 이 문제를 해결하는 접근법을 아래와 같이 생각했다.\n\n\n\n\n\n우선 N 개의 탑의 높이를 모두 Stack에 저장한다.\n\n\nO(N^2) 의 시간복잡도로 답을 구한다.\n\n\n\n\n\n여기서, 첫 번째 생각인 일단 전부 저장한다를 지우는 것이 핵심이었다.\n\n\n즉, Stack 에 값을 넣을 때 문제에서 요구하는 작업을 수행할 수 있다면 불필요한 시간 낭비를 줄일 수 있다는 것이다.\n\n\nStack 에 값을 넣을 떄 생각해 볼 조건들은 아래와 같다.\n\n\n\n\nStack에 값이 처음 들어가는가 (== Stack이 비어있는가)\n\n\n신호를 수신할 탑이 없으므로, 출력은 0 이다.\n새로운 값이 수신탑이 될 수 있으므로, push() 한다.\n\n\n\n\nStack의 top에 있는 값이 새로운 값보다 큰가\n\n\ntop이 수신탑이 될 수 있으므로, 출력은 *top이다.\n새로운 값이 수신탑이 될 수 있으므로, push() 한다.\n\n\n\n\nStack의 top에 있는 값이 새로운 값보다 작은가\n\n\ntop이 수신탑이 될 수 없으므로, 과감히 pop() 한다.\n이 때, 만약 pop() 한 후의 top도 수신탑이 될 수 없다면 연속적으로 pop()한다.\n\npop() 하는 도중, Stack 이 empty가 된다면 1번 을 행한다.\npop() 하는 도중, top이 수신탑이 될 수 있다면, 2번을 행한다.\n\n\n\n\n\n코드\n\n  \n  코드 확인 \n  \n  \n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\n \nusing namespace std;\n \nstack&lt;pair&lt;int, int&gt;&gt; towers;\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  int n;\n  cin &gt;&gt; n;\n \n  for(int i = 1; i &lt;= n; i++) {\n    int tower_height;\n    cin &gt;&gt; tower_height;\n \n    if (towers.empty()) {\n      cout &lt;&lt; 0 &lt;&lt; &#039; &#039;;\n      towers.push(make_pair(i, tower_height));\n    } else {\n      while (!towers.empty() &amp;&amp; towers.top().second &lt; tower_height) {\n        towers.pop();\n      }\n      if (towers.empty()) {\n        cout &lt;&lt; 0 &lt;&lt; &#039; &#039;;\n        towers.push(make_pair(i, tower_height));\n      } else {\n        cout &lt;&lt; towers.top().first &lt;&lt; &#039; &#039;;\n        towers.push(make_pair(i, tower_height));\n      }\n    }\n \n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n \n \n  return 0;\n}\n \n  \n"},"PS/BOJ/📕(BOJ)6198":{"title":"📕(BOJ)6198","links":["PS/BOJ/📕(BOJ)2493"],"tags":["Algorithm","PS"],"content":"문제\n[링크]\n\nN 개의 빌딩이 일렬로 나란히 서있는 모습을 상상해보자.\ni 번째 위치의 빌딩에서 오른쪽 방향을 바라볼 때, i 번째 보다 높이가 낮은 빌딩들의 옥상을 볼 수 있다.\n이 때, 볼 수 있는 옥상의 총 갯수를 구하는 문제이다.\n\n\n풀이\n\n\n어제 해결한 📕(BOJ)2493 문제의 아이디어를 이용했다.\n\n\n2493 문제는 왼쪽 방향을 이용하는 문제이기 때문에, 입력값을 한 번 뒤집어 주는 작업을 더했다.\n\n\n이후, 빌딩 간에 U 자 모양이 되는 구간의 거리 - 1 값이 관찰되는 옥상의 개수와 같기 때문에 총합을 구하여 문제를 해결했다.\n\n\n\n\nex) 10 3 7 4 12에서 U자 모양은 (10) 3 7 4 (12)이고, 둘 사이의 거리 4 - 1 == 보이는 옥상의 개수 3 이다.\n\n\n\n또, 스택이 비어있다면 현재 빌딩의 오른쪽 방향의 모든 옥상을 볼 수 있다는 의미이므로 index 값을 더했다.\n\n\n코드\n\n  \n  코드 확인 \n  \n  \n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n \nusing namespace std;\nusing ll=long long;\n \nstack&lt;pair&lt;ll, ll&gt;&gt; st;\nstack&lt;ll&gt; rev;\n \nll sum;\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n \n  int n;\n  cin &gt;&gt; n;\n \n  for (int i = 0; i &lt; n; i++) {\n    ll height;\n    cin &gt;&gt; height;\n \n    rev.push(height);\n \n  }\n \n  for(ll i = 0; i &lt; n &amp;&amp; !rev.empty(); i++) {\n    ll height = rev.top();\n    rev.pop();\n \n    if (st.empty()) {\n      // cout &lt;&lt; &quot;[+1] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i &lt;&lt; endl;\n \n      // sum += 0;\n \n      st.push(make_pair(i, height));\n    } else {\n      while (!st.empty() &amp;&amp; st.top().second &lt; height) {\n        st.pop();\n      }\n \n      if (st.empty()) {\n        // cout &lt;&lt; &quot;[+2] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i &lt;&lt; endl;\n \n        sum += i;\n \n        st.push(make_pair(i, height));\n      } else {\n        // cout &lt;&lt; &quot;[+3] h: &quot; &lt;&lt; height &lt;&lt; &quot;, add: &quot;  &lt;&lt; i - st.top().first - 1&lt;&lt; endl;\n \n        sum += (i - st.top().first - 1);\n \n        st.push(make_pair(i, height));\n      }\n    }\n \n  }\n  cout &lt;&lt; sum &lt;&lt; &#039;\\n&#039;;\n \n  return 0;\n}\n  \n\n\n참고\n\n\n문제를 해결하고 나서 다른 분들의 코드를 살펴보았다.\n\n\n[Github]의 코드를 확인했는데, 적잖이 충격적이었다.\n\n\n위 코드의 아이디어를 내 말로 정리해두자면 아래와 같다.\n\n\n\n\nStack의 상태를 항상 가장 높은 빌딩 부터 내림차순으로 나란히 정렬된 모습을 유지하기\n\n\n\n\n문제를 풀 때, 가장 많이 고민했던 부분은 10 3 7 4 12 상태에서, 10이 3개의 옥상(3 7 4)을 볼 수 있음을 어떻게 저장하는가였다.\n\n\n위 아이디어를 이용하면, 오른쪽으로 향하는 화살표가 중첩되는 이미지를 생각해볼 수 있다.\n\n\n즉, iteration 을 돌면서 하나 하나 검사할 필요 없이 한 번에 해결이 가능하다.\n\n"},"Papers/Orion":{"title":"Orion2022","links":["Data-Structure/bipartite-graph"],"tags":["ZKP","Cryptography"],"content":"Abstract\n영지식 증명은 다양한 실제 응용이 가능한 강력한 암호학적 프리미티브입니다. 그러나 기존의 영지식 증명 스킴들은 증명 크기가 간결한 대신, 증명 생성 시간에서 큰 오버헤드를 겪고 있어, 실용적인 효율성과 확장성에 한계가 있었습니다. 이러한 문제를 해결하기 위해 본 논문에서는 Orion이라는 새로운 영지식 증명 시스템을 제안했습니다.\nOrion은 필드 연산과 해시 함수에 대해 O(N)의 증명 생성 시간을 달성하고, 증명 크기는 O(\\log^2 N)으로 유지하면서도, 구체적인 효율성을 자랑합니다. 논문에서 구현된 결과에 따르면, 220개의 곱셈 게이트로 이루어진 회로에 대해 3.09초의 증명 생성 시간과 1.5MB의 증명 크기를 보여주었으며, 이는 현존하는 모든 간결한 증명 시스템 중에서 가장 빠른 시간입니다. 또한 증명 크기는 최근 제안된 다른 스킴에 비해 한 자릿수 작음을 확인했습니다.\nOrion의 이러한 효율성은 두 가지 주요 기술 덕분입니다. 첫째, 무작위 이분 그래프가 손실 없는 확장 그래프인지 여부를 검사하는 새로운 알고리즘을 제안하여, 손실 없는 확장 그래프를 매우 높은 확률로 샘플링할 수 있게 했습니다. 이 기술은 기존 영지식 증명 스킴의 효율성과 보안성을 크게 향상시킬 수 있습니다. 둘째, code switching이라는 효율적인 증명 구성 스킴을 개발하여, 증명 크기를 계산 크기에 대해 제곱근에서 polylogarithmic으로 감소시켰습니다. 이 스킴은 증명 생성 시간에 아주 작은 오버헤드만을 발생시키는 효율성을 보장합니다.\n\n1. Introduction\n영지식 증명 (ZKP)은 Prover로 하여금 명제에 관한 어떠한 추가 정보도 제공하지 않으면서 Verifier에게 자신의 명제가 유효함을 납득시킬 수 있도록 합니다.\nGoldwasser, Micali, Rackoff (GMR89)의 세미나 논문에서 처음 소개된 이후, ZKP는 순수한 이론적 흥미로부터 구체적으로 효율적인 암호 프리미티브로까지 진화해오며 실용적인 실제 응용들을 이끌어 왔습니다.\n대부분은 블록체인과 암호화폐 업계에서 프라이버시(Zcash)와 확장성의 향상(zkRollup)을 얻기 위해 사용되어 왔습니다.\n최근에는 zero-knowledge machine learning, zero-knowledge program analysis, zero-knowledge middle box와 같은 형태로도 응용되고 있습니다.\nZKP에 관해 세 가지 주요 효율성 측정 지표가 있습니다.\n\nProver Time: Prover가 \\pi \\; (proof) 를 생성하는데 드는 오버헤드\nProof Size: Prover와 Verifier 간의 전체 소통량\nVerifier Time: Verifier가 \\pi 를 검증하는데 드는 시간\n\n근래의 많은 발전들에도 불구하고 ZKP의 효율성은 다양한 응용에 활용되기에 충분히 좋지는 않습니다.\n특히, Prover Time은 ZKP 스킴이 큰 명제(large statement)으로 확장되는 것을 막고 있는 주요 병목입니다.\n[GLS+]에서도 지적하듯이 N개의 게이트로 이루어진 산술회로(arithmetic circuit)로 모델링되는 주장(명제, statement)을 증명하기 위해서, 현존하는 ‘간결한(succinct)’ 크기의 증명을 갖는 ZKP 스킴은 다음 두 가지 방식 중 하나를 사용합니다.\n\n고속 푸리에 변환(FFT)\n\n리드-솔로몬 코드 인코딩(Reed-Solomon Code Encoding) 또는 다항식 보간법(polynomial interpolation)을 수행하기 위해 사용됩니다.\nField addition, multiplication 연산에 대해 O(N \\log N) 시간 복잡도를 갖습니다.\n\n\n다중 스칼라 지수화(Multi-Scalar Exponentiation)\n\n이 방법은 이산 로그 가정(discrete-logarithm assumption)이나 이중 선형 사상(bilinear map)에 기반하며, 크기 O(N)의 벡터를 처리합니다.\nField Multiplication 연산에 대해 O(N \\log | \\mathbb{F} |) 의 시간 복잡도를 가지며, 이 때 | \\mathbb{F} | 는 Finite Field의 크기를 의미합니다.\nPippenger 알고리즘 (Pip)을 사용하면 시간 복잡도를 O(N \\log | \\mathbb{F} | / \\log N)으로 개선할 수는 있지만, 보안성을 보장하기 위해 \\log | \\mathbb{F} | = \\omega (\\log N) 을 만족해야 합니다. 따라서, 최소한 \\log N 보다는 빠르게 증가한다는 의미이므로 충분히 큰 | \\mathbb{F} | 가 필요함을 의미합니다. 즉, 여전히 초선형(super-scalar) 입니다.\n\n\n\n이 두 연산은 결국 prover time에서 이론적으로나 실제로나 주된 비용을 차지하게 됩니다.\n간결한 증명크기에 대해 이렇게 증명을 생성하는 것과 달리, 문헌에서 설명하는 유일한 예외에는 [BCG+17], [BCG20], [BCL22], [GLS+]에서 제시된 스킴들이 있습니다.\n\n\nProver Time\n\n[BCG+17]: 선형 시간으로 인코딩할 수 있는 오류 수정 코드(linear-time encodable error-correcting code)를 사용하여,\n필드 연산에서 O(N)의 시간을 달성 (ZKP에서 최초로 linear time을 달성).\n[BCG20]: [BCG+17]과 동일한 O(N) prover time 유지.\n[BCL22]: [BCG20]과 동일한 O(N) prover time 유지.\n[GLS+]: 랜덤화된 구성 방식을 통해 선형 시간 인코딩이 가능한 코드를 활용하여 O(N)의 prover time을 유지.\n\n\n\nProof Size\n\n[BCG+17]: O(\\sqrt{N}) (linear-time 인코딩을 통해 기존 대비 효율성 향상)\n[BCG20]: 텐서 코드를 통해 임의의 상수 c에 대해 O(N^{1/c})로 개선\n[BCL22]: PCP(Probabilistic Checkable Proof)와의 generic proof composition을 통해 \\text{polylog}(N)까지 향상\n[GLS+]: 랜덤화된 구성 방식을 통해 선형 시간 인코딩을 사용했으나, O(\\sqrt{N})에 머무름\n\n\n\nSecurity\n\n[GLS+]: 보안 보장(soundness error)이 회로 크기에 대해 역다항식(inverse polynomial) 수준으로, 이는 충분히 작지 않음\n\n\n\n따라서, ZKP 스킴에 관해 아래의 의문을 해결할 여지가 여전히 남아있습니다.\n\nProver Time이 O(N), Proof Size가 \\text{polylog}(N)인 구체적이고 효율적인 ZKP 스킴을 구축할 수 있는가?\n\n\n1.1 Our Contribution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSchemeProver timeProof sizeVerifier timeSoundness errorConcrete efficiency[BCG+17]O(N)O(\\sqrt{N})O(N)\\text{negl}(N)✗[BCG20]O(N)O(N^{1/c})O(N)\\text{negl}(N)✗[BCL22]O(N)\\text{polylog}(N)O(N)\\text{negl}(N)✗[GLS+]O(N)O(\\sqrt{N})O(N)O\\left(\\frac{1}{\\text{poly}(N)}\\right)✔   Orion  O(N)O(\\log^2 N)O(N)\\text{negl}(N)✔\n\n\n본 논문에서는 위 질문에 대한 답으로 새로운 ZKP 스킴을 제안합니다.\n구체적으로 본 논문에서 제시한 스킴은 아래의 특징을 갖습니다.\n\n본 논문에서는 압도적인 확률로 constant relative distance를 갖는 임의 구조의 linear-time encodable code를 제안합니다.\n이러한 code는 linear-time ZKP Schemes ([BCG+17], [BCG20], [BCL22], [GLS+])에서 모두 사용되었으므로, 본 논문에서의 새로운 construction도 이러한 효율성을 개선합니다.\n핵심적인 technique은 small set expansion problem을 기반으로 임의의 Graph가 good expander graph인지 검사하는 것입니다.\n본 논문에서는 O(\\log^2 N) 크기의 Proof Size를 효율적으로 얻는 새로운 reduction을 제시합니다.\n이 기술은 [RR20]에서 제안된 “code switching”이라는 이름의 Proof Composition (증명 합성) 입니다.\n본 논문에서는 linear-time encodable code의 encoding circuit을 이용해,\nProver Time에 적은 오버헤드를 일으키며 [BCG20, GLS+]의 Proof Size를 O(\\sqrt{N}) 에서 O(\\log^2N) 으로까지 reduce하는 효율적인 예시를 개발했습니다.\n마지막으로, 본 논문에서는 Orion 이라는 이름의 새로운 ZKP Scheme을 개발하고 이를 실험적으로 평가했습니다.\n2^{20}개의 Gate로 이루어진 Circuit (R1CS에서 2^{20}개의 constraint로 구성)에서 아래와 같은 측정 결과를 얻었습니다.\nOrion은 현존하는 ZKP Scheme 중에서 가장 빠른 Prover Time을 가집니다.\nProof Size도 [GLS+]보다 6.5배 더 작습니다.\n또한, 이 Scheme은 그럴듯하게 Post-Quantum도 만족하며 Fiat-shamir를 활용하면 Non-interactive하게도 만들 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNameValueProver Time3.09sProof Size1.5MBVerifier Time70ms\n\n"},"index":{"title":"Welcome to Quartz","links":[],"tags":[],"content":"Since 2024…\n빈수레라 요란합니다."}}