{"Notes/16AUG,-PSE-Core-Program":{"title":"Simple ZK Static Program Analysis","links":[],"tags":["PSE_Core_Program","ZKP","Hackathon"],"content":"들어가며\n8월 16일 금요일의 PSE Core Program off-line meet 시간에는 ZKP 를 활용한 미니 해커톤이 진행되었다.\n나는 Orion 논문을 읽다가 발견했던 흥미로운 주제인 ZK Static Program Analysis 로 미니 해커톤에 참가했다. 결과물로 구현하고자 하는 것은 아래와 같다.\n\n임의의 Rust 프로그램 소스코드에 division by zero를 일으킬 수 있는 코드가 없음을 ZKP로 증명 하는 프로그램\n\nZKP 프로젝트인만큼 원본 소스코드에 관해서는 zero-knowledge인 것이 특징이다.\n안전한 소스코드 임을 직접 제출할 필요 없이도 증명할 수 있는 것이다.\nParser와 Circuit은 아래와 같이 설게 및 구현되었다.\n\nParser: Rust 코드를 분석해 Circuit의 입력값으로 변환하는 단계\nCircuit: 분석된 Rust코드를 통해 정적 분석을 수행하는 단계\n\n구현물은 github.com/c0np4nn4/simple_zk_spa 에서 확인할 수 있다.\n\n구현 상세\n1. Parser\nParser는 Rust 문법으로 작성된 소스코드를 읽고 각 줄을 분석하여 아래 형태의 배열로 변환한다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n원소 1원소 2원소 3원소 4Op Type명령어 종류lhs elem좌항 원소rhs elem 1우항 원소 1rhs elem 2우항 원소 2\n아주 간단한 형태의 예시 프로그램 사용을 가정했기에 분석기도 매우 간결하게 구현하였다.\n명령어의 종류는 아래와 같이 총 4개로만 설계했다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n명령어 번호명령어 종류명령어 설명0NoOp프로그램 종료를 의미하는 동작 코드 모든 배열의 원소가 0 ([0, 0, 0, 0])1Assign좌항 원소에 우항 원소 1을 저장 이 때, 우항 원소 2는 무조건 02Addition좌항 원소에 우항 원소 1과 우항 원소 2의 덧셈 결과를 저장3Division좌항 원소에 우항 원소 1과 우항 원소 2의 나눗셈 결과를 저장\n또, 변수(variable)와 값(value)를 아래와 같이 구분했다.\n\n변수는 모두 홀수로 표기한다.\n값은 모두 2를 곱한 값으로 배열 원소에 저장한다.\n\n1-1. Example\n아래와 같은 예제 소스 코드 example.rs가 있다고 해보자.\nfn main() {\n\tlet x: i64 = 7;\n\tlet y: i64 = -7;\n\tlet z: i64 = x + y;\n\tlet a: i64 = 4 / z;\n}\n각각의 줄은 다음과 같이 해석된다.\n{\n\t[1, 1,  14, 0], # [  &#039;assign&#039;,  &#039;x&#039;,  7 * 2,  nil]\n\t[1, 3, -14, 0], # [  &#039;assign&#039;,  &#039;y&#039;, -7 * 2,  nil]\n\t[2, 5,   1, 3], # [&#039;addition&#039;,  &#039;z&#039;,    &#039;x&#039;,  &#039;y&#039;]\n\t[3, 7,   8, 5]  # [&#039;division&#039;,  &#039;a&#039;,  4 * 2,  &#039;z&#039;]\n}\n값에 해당하는 7, -7, 4 는 모두 2배 곱해져서 배열로 정리되어 있음을 확인할 수 있다.\n\n2. Circuit\nParser는 단순하게 구현만 하면 됐지만, Circuit에서는 정적분석의 방법을 정하고 이를 구현해야 했다.\n이에 관해 “정적 분석은 계산 안하기 하는 것이라 생각할 수 있다.” 라는 조언을 바탕으로 아래와 같이 분석 방법을 정했다.\n\n양수인 값은 +로 둔다.\n음수인 값은 -로 둔다.\n덧셈의 피연산자에 관해 아래 세 가지 경우로 나뉠 수 있다.\n\n(양수) + (양수) = 양수, 즉 + 가 된다.\n(음수) + (음수) = 음수, 즉 -가 된다.\n(양수) + (음수) = ??\n\n\n\n양수와 음수를 더한 경우 결과를 T라고 두었으며, 이는 \\{+, -, 0\\} 중 하나이다.\ndivision by zero 는 나눗셈의 제수(분모)가 0일 때 발생한다.\n하지만,정확한 계산 수행없이 에러 발생의 가능성을 분석하기 위해서는 ‘제수가 T 인지’를 검사하는 것으로 충분하다.\n만약 검사하는 코드가 우주선이나 비행기에 들어가는 코드라고 생각해보자.\ndivision by zero 에러로 인해 프로그램이 정지하거나 문제를 일으키는 경우, 우주비행사 또는 비행기 탑승객들의 생명에 직접적인 영향을 끼칠 수 있다.\n따라서, 실제로 에러가 발생할지 여부는 확실치 않더라도 가능성을 검출하는 것은 경우에 따라 대단히 중요해질 수 있음을 생각할 수 있다.\n2-1. 변수 값 저장\n홀수로 표시한 변수는 결국 어떠한 정보를 갖게 된다.\n정적 분석에서는 실제 계산이 없이 분석이 진행되야 하므로, Circuit 내에서는 아래와 같은 작업이 이뤄진다.\n\n값의 크기는 잊고 부호만 변수에 저장\n\n예를 들어, 아래와 같은 코드가 있다고 해보자.\nfn main() {\n\tlet p: i64 = +11;\n}\n이를 Parser를 통해 배열로 변환하면 아래와 같은 결과를 얻는다.\n{\n\t[1, 1, 22, 0] # [&#039;assign&#039;,  &#039;p&#039;,  11 * 2,  nil]\n}\n그리고 이를 Circuit 내부에서는 값의 크기인 11은 잊어버리고 그 부호인 +만 남긴다.\np = +\n2-2.  T 계산 과정\nT값은 덧셈연산을 통해 얻을 수 있다.\n따라서, Op Type이 Addition 인 경우에 rhs elem 1과 rhs elem 2의 부호정보를 확인하고 \\{+, -, T\\} 중 하나의 결과를 lhs elem에 저장하는 식으로 circuit을 구성했다.\n\n결과"},"Notes/NEAR,-FastAuth":{"title":"NEAR, FastAuth","links":[],"tags":[],"content":""},"Notes/PSE-Core-Group-Resources":{"title":"PSE Core Group Resources","links":[],"tags":["PSE_Core_Program","Cryptography"],"content":"2024년 PSE Core Group에서 활용한 자료들을 정리한 문서입니다.\nWeek 1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTitleTagLinkKZG  articleKZG, PCSdankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.htmlKZG paperKZG, PCSwww.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf"},"Notes/Sui-(로컬)-DApp-개발-연습":{"title":"Sui (로컬) DApp 개발 연습","links":["Notes/Sui,-DApp-Frontend"],"tags":["SUI","개발","Web3"],"content":"우선 아래와 같이 입력해 새로운 프로젝트를 생성합니다.\nsui move new my_frist_package\n생성된 폴더인 my_first_package로 가보면 manifest file 인 Move.toml과 소스코드가 있는 sources 디렉토리가 있습니다.\n\n1. Package 정의하기\nsources/my_first_package.move 는 사실 아무런 기능을 하지 않습니다.\nmove로 작성된 소스코드는 module 을 정의해야 합니다.\nDocs에서 제공하는 예시 코드를 이미 생성된 sources/my_first_package.move 소스 코드의 바로 밑에 복붙하면 됩니다. 헷갈릴 수 있으므로 전체 코드를 아래에 첨부합니다.\n/*\n/// Module: my_first_package\nmodule my_first_package::my_first_package;\n*/\n \nmodule my_first_package::example {\n \n    // Part 1: These imports are provided by default\n    // use sui::object::{Self, UID};\n    // use sui::transfer;\n    // use sui::tx_context::{Self, TxContext};\n \n    // Part 2: struct definitions\n    public struct Sword has key, store {\n        id: UID,\n        magic: u64,\n        strength: u64,\n    }\n \n    public struct Forge has key {\n        id: UID,\n        swords_created: u64,\n    }\n \n    // Part 3: Module initializer to be executed when this module is published\n    fun init(ctx: &amp;mut TxContext) {\n        let admin = Forge {\n            id: object::new(ctx),\n            swords_created: 0,\n        };\n \n        // Transfer the forge object to the module/package publisher\n        transfer::transfer(admin, ctx.sender());\n    }\n \n    // Part 4: Accessors required to read the struct fields\n    public fun magic(self: &amp;Sword): u64 {\n        self.magic\n    }\n \n    public fun strength(self: &amp;Sword): u64 {\n        self.strength\n    }\n \n    public fun swords_created(self: &amp;Forge): u64 {\n        self.swords_created\n    }\n \n    // Part 5: Public/entry functions (introduced later in the tutorial)\n    \n    // Part 6: Tests\n}\nRust와 상당히 비슷하기 때문에 익숙하다면 읽기 수월합니다..\n위 내용을 기존의 my_first_package.move 에 복붙합니다.\n2. Build your package\n아래 명령어를 입력해서 build를 진행합니다.\nsui move build\n\n인터넷 문제가 없다면 위 그림과 같이 Build 할 수 있습니다.\nbuild 폴더를 살펴보면 bytecode로 컴파일된 example.mv 파일을 확인할 수 있습니다.\n(사진은 xxd로 보기 예쁘게 변환해 둔 결과입니다)\n\n3. Testing\n개발에 있어서 testing이 빠질 수 없습니다.\ntests/ 폴더는 일단 신경쓰지 말고 위에서 수정한 sources/my_first_package.move 를 계속 수정합니다. 헷갈릴 수 있으므로 전체 코드를 첨부해두겠습니다.\n/*\n/// Module: my_first_package\nmodule my_first_package::my_first_package;\n*/\n \nmodule my_first_package::example {\n \n    // Part 1: These imports are provided by default\n    // use sui::object::{Self, UID};\n    // use sui::transfer;\n    // use sui::tx_context::{Self, TxContext};\n \n    // Part 2: struct definitions\n    public struct Sword has key, store {\n        id: UID,\n        magic: u64,\n        strength: u64,\n    }\n \n    public struct Forge has key {\n        id: UID,\n        swords_created: u64,\n    }\n \n    // Part 3: Module initializer to be executed when this module is published\n    fun init(ctx: &amp;mut TxContext) {\n        let admin = Forge {\n            id: object::new(ctx),\n            swords_created: 0,\n        };\n \n        // Transfer the forge object to the module/package publisher\n        transfer::transfer(admin, ctx.sender());\n    }\n \n    // Part 4: Accessors required to read the struct fields\n    public fun magic(self: &amp;Sword): u64 {\n        self.magic\n    }\n \n    public fun strength(self: &amp;Sword): u64 {\n        self.strength\n    }\n \n    public fun swords_created(self: &amp;Forge): u64 {\n        self.swords_created\n    }\n \n    // Part 5: Public/entry functions (introduced later in the tutorial)\n    \n    // Part 6: Tests\n \n \n    #[test]\n    fun test_sword_create() {\n        // Create a dummy TxContext for testing\n        let mut ctx = tx_context::dummy();\n \n        // Create a sword\n        let sword = Sword {\n            id: object::new(&amp;mut ctx),\n            magic: 42,\n            strength: 7,\n        };\n \n        // Check if accessor functions return correct values\n        assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n \n        let dummy_address = @0xCAFE;\n        transfer::public_transfer(sword, dummy_address);\n    }\n}\n그리고 아래 명령어를 입력하면 됩니다.\nsui move test\n\n3.  Sui-specific testing\nSui 에서 제공하는 test_scenario 모듈을 사용하면 Sui를 사용하는 맥락에서의 testing도 가능합니다.\n우선 sword를 생성하는 함수를 하나 추가합니다.\npublic fun sword_create(magic: u64, strength: u64, ctx: &amp;mut TxContext): Sword {\n    Sword {\n        id: object::new(ctx),\n        magic: magic,\n        strength: strength,\n    }\n}\n그리고 아래 test code를 추가합니다.\n    #[test]\n    fun test_sword_transactions() {\n        use sui::test_scenario;\n \n        // Create test addresses representing users\n        let initial_owner = @0xCAFE;\n        let final_owner = @0xFACE;\n \n        // First transaction executed by initial owner to create the sword\n        let mut scenario = test_scenario::begin(initial_owner);\n        {\n            // Create the sword and transfer it to the initial owner\n            let sword = sword_create(42, 7, scenario.ctx());\n            transfer::public_transfer(sword, initial_owner);\n        };\n \n        // Second transaction executed by the initial sword owner\n        scenario.next_tx(initial_owner);\n        {\n            // Extract the sword owned by the initial owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Transfer the sword to the final owner\n            transfer::public_transfer(sword, final_owner);\n        };\n \n        // Third transaction executed by the final sword owner\n        scenario.next_tx(final_owner);\n        {\n            // Extract the sword owned by the final owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Verify that the sword has expected properties\n            assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n            // Return the sword to the object pool (it cannot be simply &quot;dropped&quot;)\n            scenario.return_to_sender(sword)\n        };\n        scenario.end();\n    }\n주목할 점은 scenario.take_from_sender&lt;Type&gt;(); 메서드 입니다.\n이를 이용해 손쉽게 특정 타입(Sword)의 address-owned object 를 transaction에서 다룰 수 있게 됩니다.\n마지막 transaction에서 scenario.return_to_sender(sword)를 통해 앞에서의 drop 문제를 조금 더 유연하게 처리하고 있습니다.\n이 때, test_utils에서 제공하는 destroy&lt;T&gt;()를 사용할 수도 있습니다.\n마지막 코드만 다시 적어보면 아래와 같습니다.\n        use sui::test_utils;\n \n\t\t// ...\n \n        // Third transaction executed by the final sword owner\n        scenario.next_tx(final_owner);\n        {\n            // Extract the sword owned by the final owner\n            let sword = scenario.take_from_sender&lt;Sword&gt;();\n            // Verify that the sword has expected properties\n            assert!(sword.magic() == 42 &amp;&amp; sword.strength() == 7, 1);\n            // Return the sword to the object pool (it cannot be simply &quot;dropped&quot;)\n            // scenario.return_to_sender(sword)\n            test_utils::destroy&lt;Sword&gt;(sword)\n        };\n \n\n4. Module Initialize\nSmart Contract의 constructor 같은 존재입니다.\ninit() 함수로 작성되며, 아래와 같이 TxContext 타입을 인자로 받는 형식으로 작성되어야 합니다.\n\nfun init(ctx: &amp;TxContext)\nfun init(ctx: &amp;mut TxContext)\nfun init(otw: EXAMPLE, ctx: &amp;TxContext)\nfun init(otw: EXAMPLE, ctx: &amp;mut TxContext)\n\n또, 아래와 같은 규칙이 있습니다.\n\nReturn value 없음\nPrivate visibility\nmodule의 one-time witness value 를 첫 번째 인자로 받을 수 있음\n\n\n5. Publish a package\nSmart contract Deploy에 해당하는 작업입니다.\nnetwork는 active-env이고, 계정은 active-address입니다.\n아래와 같이 입력해서 배포할 수 있습니다.\nsui client publish\n\n물론 배포할 때는 gas 가 필요합니다.. (faucet에서 얻으면 됩니다)\n\n결과는 아래와 같이 아주 예쁜 TUI 로 보여줍니다.\n\n결과를 아래와 같이 나뉘어진 블록으로 설명하고 있습니다.\n\nTransaction Data\nTransaction Effect\nTransaction Block Event\nObject Changes\nBalance Changes\n\n이 중 active-address가 소유한 object를 아래와 같이 명령어를 입력해 살펴볼 수 있습니다.\nsui client objects\n\nObject 종류에 대해 설명하면 다음과 같습니다.\n\nCoin: faucet에서 받은 토큰입니다.\nUpgradeCap: publish 한 Package들이 여기에 receipt로 남게 된다고 합니다. 향후 package 를 업그레이드 할 때 사용하거나, burn 해서 업그레이드 할 수 없게 만들 때 이용한다고 합니다.\nForge: publish 한 Package의 init 함수에서 Forge object를 만들어서 (admin이라는 변수 명 사용) 현재 active-address인 ctx.sender()에게 transfer() 한 결과로 이해할 수 있습니다.\n\n4-1. Interact with Package\nPublish 된 Package와 상호작용하는 방법을 살펴봅니다.\n가장 간단한 방법은 아래 명령어를 사용하는 것입니다.\nsui client call --package &lt;PACKAGE-ID&gt; --module &lt;MODULE&gt; --functio &lt;FUNCTION&gt; --args ...\n\n\n                  \n                  Note\n                  \n                \n\nPACKAGE-ID 를 까먹었다면 다음과 같은 순서로 구할 수 있습니다.\n\n우선 sui client objects를 입력해 &lt;PACKAGE-ID&gt;::&lt;MODULE&gt;::Object로 명시된 objectType 을 확인합니다.\n\n\n\n중간에 생략된 &lt;PACKAGE-ID&gt;를 확인하기 위해서는 sui client object &lt;object-id&gt;를 입력하면 됩니다.\n\n\n\n\n실제로 sui client call 을 해보면 아래와 같습니다.\n지금은 Forge object를 알고 있기 때문에 이를 인자로 사용하는 swords_created을 호출해보았습니다.\n\n\n\n                  \n                  Important\n                  \n                \n\nDocs 에서는 이보다 좀 더 유연한 방법인 ptb를 설명하고 있습니다.\n이는 아래와 같이 명령어를 입력하는 방식입니다.\nsui client ptb \\\n    --assign forge @&lt;FORGE-ID&gt; \\\n    --assign to_address @&lt;TO-ADDRESS&gt; \\\n    --move-call &lt;PACKAGE-ID&gt;::example::sword_create 10 20 \\\n    --assign sword \\\n    --transfer-objects &quot;[sword]&quot; to_address \\\n    --gas-budget 20000000\n\n\n\n\n\n5. Debugging\n개발 과정에서 디버깅도 아주 요긴하게 사용됩니다.\nuse std::debug;\n \ndebug::print(&amp;v);\ndebug::print_stack_trace();\n위와 같은 방법으로 적재적소에서 값을 찍어보면 됩니다.\n\n6. Client App w/ Sui TS SDK\n다음 글에서 이어 정리하겠습니다…\nSui, DApp Frontend"},"Notes/Sui-(로컬)-개발-환경-구축":{"title":"Sui (로컬) 개발 환경 구축","links":[],"tags":["SUI","Web3","개발"],"content":"Docs 읽고 한글로 정리해두려고 합니다…\nTL;DR\n\nTool, Sui 설치\nLocalnet 구동\n\nsui start with options (faucet, regensis)\n\n\nLocalnet &lt;&gt; CLI 연결\n\nsui client &lt;env&gt;\n\n\nLocalnet Account 생성\n\nsui client &lt;address&gt;\n\n\nLocalnet Faucet으로 토큰 확보\n\nsend request using curl command\n\n\n\n1. Sui 설치\n맥북이면 brew로 해도 되고, Rust가 설치되어 있으면 cargo로 해도 됩니다…\n저는 Cargo 로 설치했습니다.\nbrew install sui\ncargo install --locked --git github.com/MystenLabs/sui.git --branch testnet sui\n \nrustup update stable\n2. network 구동\n참고로 Sui는 Devnet, Testnet 이렇게 두 개로 나눠지길래 뭔가 싶었는데…\n\nblog.sui.io/sui-testnet-wave-1 에서 그렇다고 합니다…\n요약하면 Devnet은 Mysten Labs이 주도적으로 돌리고 있고, Testnet은 20 validators가 돌리고 있고의 차이…\n\n여기서는 Localnet 돌리는 것만 정리합니다.\n\n위에서 sui 가 제대로 설치됐다면 아래 스크립트를 입력해서 로컬넷을 시작할 수 있습니다.\nRUST_LOG=&quot;off,sui_node=info&quot; sui start --with-faucet --force-regenesis\n실행 결과는 아래와 같습니다.\n\n옵션은 docs에서도 잘 설명하고 있지만.. 대략 아래와 같습니다.\n\nRUST_LOG: sui_node=info 정보를 제외하고는 다 무시한다는 뜻, warning 같은거 안띄워서 깔끔\n--with-faucet: faucet 기능도 함께 시작\n--force-regenesis: 상태를 완전 재시작, 이전 상태나 이후 상태와 완전 독립적인 로컬 네트워크 시작\n\n즉, 로컬넷의 상태를 계속 유지하면서 개발을 하든… 뭔가 하고 싶으면 --force-regensis만 제거하고 위 스크립트를 실행하면 됩니다.\n2-1. 로컬넷 확인\n제대로 돌아가는지 확인하는건 curl로 request를 하나 보내보면 됩니다.\nif command -v jq &amp;&gt; /dev/null\nthen\n    echo &quot;jq 명령어가 발견되었습니다. curl 명령어를 실행합니다.&quot;\n    curl --location --request POST &#039;http://127.0.0.1:9000&#039; \\\n    --header &#039;Content-Type: application/json&#039; \\\n    --data-raw &#039;{\n      &quot;jsonrpc&quot;: &quot;2.0&quot;,\n      &quot;id&quot;: 1,\n      &quot;method&quot;: &quot;sui_getTotalTransactionBlocks&quot;,\n      &quot;params&quot;: []\n    }&#039; | jq\nelse\n    echo &quot;jq 명령어가 설치되어 있지 않습니다.&quot;\nfi\n아래와 같이 확인할 수 있습니다.\n\n3. 네트워크(로컬넷)에 Sui CLI 연결\nSui CLI를 처음 사용할 때 config file 을 만들게 됩니다.\n\n위와 같이 sui client를 입력하고 y, &lt;ENTER&gt;, 0 해주면 됩니다.\n아래 스크립트를 입력해 로컬넷을 사용하도록 설정합니다.\nsui client new-env --alias local --rpc http://127.0.0.1:9000\n옵션에 대한 설명은 다음과 같습니다.\n\nsui client new-env: 새로운 네트워크 환경을 등록합니다.\n--alias local: local이라는 이름으로 새로운 환경을 등록합니다.\n--rpc http://127.0.0.1:9000: rpc endpoint 정보를 등록합니다.\n\n즉, local이라는 이름으로 http://127.0.0.1:9000 인 로컬넷 환경을 새로 하나 만드는 명령어입니다.\n새로 생성한 환경으로 switch 해줍니다.\nsui client switch --env local\n참고로 여기서 사용한 switch는 --env 뿐만 아니라 --address도 가능합니다.\n자세한 사항은 sui client switch --help로 확인할 수 있습니다.\nsui client envs\n위 명령어를 입력하면 현재 저장된 환경들을 모두 확인할 수 있습니다.\n\n4. Active address 확인하기\n그냥 주어진 address 를 사용해도 되지만, 기왕이면 직접 만든 address를 사용해보는게 좋다고 생각합니다.\n# sui client new-address ed25519 &lt;nickname&gt;\nsui client new-address ed25519 p4nn4\n\n위 recoveryPhrase를 이용해 wallet extension에서도 계정을 import 해올 수 있습니다 (물론 localnet으로 변경해주셔야 합니다…)\n\n참고로 계정에 관한 정보는 앞서 생성한 config file 위치에 가면 확인할 수 있습니다.\n보통 홈 디렉토리 (~/)에 .sui 폴더로 존재합니다.\n\n\n5. Faucet 으로 토큰 얻기\n앞서 로컬넷을 실행할 때 --with-faucet 옵션을 넣었으므로 간단히 아래 스크립트를 입력하여 토큰을 받아 올 수 있습니다.\n# curl --location --request POST &#039;http://127.0.0.1:9123/gas&#039; \\\n# --header &#039;Content-Type: application/json&#039; \\\n# --data-raw &#039;{\n#     &quot;FixedAmountRequest&quot;: {\n#         &quot;recipient&quot;: &quot;&lt;YOUR SUI ADDRESS&gt;&quot;\n#     }\n# }&#039;\n \ncurl --location --request POST &#039;http://127.0.0.1:9123/gas&#039; \\\n--header &#039;Content-Type: application/json&#039; \\\n--data-raw &#039;{\n    &quot;FixedAmountRequest&quot;: {\n        &quot;recipient&quot;: &quot;0xb3087987a1769fa853f5d2bddead6414ca4b0f7f17c1f8932937ef7410dcbbc5&quot;\n    }\n}&#039;\n\n1,000 sui 를 받아왔습니다…\n\n이 정도 하면 개발 환경 구축은 된 것 같습니다.\n다음은 move언어를 이용해 smart contract에 해당하는 프로그램 개발을 다뤄봅니다."},"Notes/Sui,-DApp-Frontend":{"title":"Sui, DApp Frontend","links":[],"tags":["SUI","개발","Web3"],"content":"1. Example\nyarn create @mysten/dapp --template react-client-dapp\n \n# &lt;ENTER&gt;\n \ncd my-first-sui-dapp\n \nyarn\n \nyarn dev\n\n지갑을 연결해볼 수 있는 예제 사이트가 나옵니다.\n\n2. 코드 분석\n2-1. Provider\nmain.tsx 에는 세 종류의 Provider가 존재합니다.\n// main.tsx\nReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render(\n  &lt;React.StrictMode&gt;\n    &lt;Theme appearance=&quot;dark&quot;&gt;\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;SuiClientProvider networks={networkConfig} defaultNetwork=&quot;testnet&quot;&gt;\n          &lt;WalletProvider autoConnect&gt;\n            &lt;App /&gt;\n          &lt;/WalletProvider&gt;\n        &lt;/SuiClientProvider&gt;\n      &lt;/QueryClientProvider&gt;\n    &lt;/Theme&gt;\n  &lt;/React.StrictMode&gt;,\n);\n\nQueryClientProvider\nSuiClientProvider\nWalletProvider\n\n2-2. Connect to Wallet\nApp.tsx 에서 ConnectButton 컴포넌트를 활용하여 지갑을 연결할 수 있도록 합니다.\n// App.tsx\nimport { ConnectButton } from &#039;@mysten/dapp-kit&#039;;\n \nfunction App() {\n\treturn (\n\t\t&lt;div className=&quot;App&quot;&gt;\n\t\t\t&lt;header className=&quot;App-header&quot;&gt;\n\t\t\t\t&lt;ConnectButton /&gt;\n\t\t\t&lt;/header&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n2-3. Account 정보 활용\n지갑이 연결 되었으므로, userCurrentAccount() Hook을 아래와 같이 활용합니다.\n// WalletStatus.tsx\nimport { useCurrentAccount } from &quot;@mysten/dapp-kit&quot;;\nimport { Container, Flex, Heading, Text } from &quot;@radix-ui/themes&quot;;\nimport { OwnedObjects } from &quot;./OwnedObjects&quot;;\n \nexport function WalletStatus() {\n  const account = useCurrentAccount();\n \n  return (\n    &lt;Container my=&quot;2&quot;&gt;\n      &lt;Heading mb=&quot;2&quot;&gt;Wallet Status&lt;/Heading&gt;\n \n      {account ? (\n        &lt;Flex direction=&quot;column&quot;&gt;\n          &lt;Text&gt;Wallet connected&lt;/Text&gt;\n          &lt;Text&gt;Address: {account.address}&lt;/Text&gt;\n        &lt;/Flex&gt;\n      ) : (\n        &lt;Text&gt;Wallet not connected&lt;/Text&gt;\n      )}\n      &lt;OwnedObjects /&gt;\n    &lt;/Container&gt;\n  );\n}\n2-4. On-chain data 활용\nuseSuiClientQuery 같은 hook 을 이용하면 현재 계정이 소유하고 있는 object를 가져오는 것도 가능합니다.\nimport { useCurrentAccount, useSuiClientQuery } from &#039;@mysten/dapp-kit&#039;;\n \nfunction ConnectedAccount() {\n\tconst account = useCurrentAccount();\n \n\tif (!account) {\n\t\treturn null;\n\t}\n \n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&lt;div&gt;Connected to {account.address}&lt;/div&gt;;\n\t\t\t&lt;OwnedObjects address={account.address} /&gt;\n\t\t&lt;/div&gt;\n\t);\n}\n \nfunction OwnedObjects({ address }: { address: string }) {\n\tconst { data } = useSuiClientQuery(&#039;getOwnedObjects&#039;, {\n\t\towner: address,\n\t});\n\tif (!data) {\n\t\treturn null;\n\t}\n \n\treturn (\n\t\t&lt;ul&gt;\n\t\t\t{data.data.map((object) =&gt; (\n\t\t\t\t&lt;li key={object.data}&gt;\n\t\t\t\t\t&lt;a href={`example-explorer.com/object/${object.data}`}&gt;\n\t\t\t\t\t\t{object.data}\n\t\t\t\t\t&lt;/a&gt;\n\t\t\t\t&lt;/li&gt;\n\t\t\t))}\n\t\t&lt;/ul&gt;\n\t);\n}"},"Notes/Tokio_1":{"title":"Tokio_1","links":[],"tags":["Rust","Tokio"],"content":"Overview\nTokio는 Rust 언어를 위한 asynchronous runtime 입니다.\n네트워킹 프로그래밍에 활용될 수 있으며, 아래와 같은 주요 component를 제공합니다.\n\nasynchronous code 를 실행하기 위한 multi-threaded runtime\nStandard library의 asynchronous 버전\n\nProject 에서 Tokio의 역할\nasynchronous 방식으로 코드를 작성하면 동시에 여러 작업을 할 때 드는 cost를 많이 줄일 수 있습니다. asynchronous code는 Tokio 라이브러리의 asynchronous runtime 으로 실행할 수 있습니다. 많은 Standard library들은 “blocking”으로 인해 이러한 비동기 환경에서 실행할 수 없는 경우가 있습니다. 이를 위해 Tokio는 비동기 버전의 라이브러리를 제공합니다.\nTokio의 장점\nTokio를 사용했을 때의 장점을 아래와 같이 볼 수 있습니다.\n\nFast\n\nRust 언어 자체가 속도가 빠릅니다.\nRust 언어에서 제공하는 async/await로 concurrent task를 돌릴 수 있으므로, Scalable 합니다.\n\n\nReliable\n\nRust 언어의 메모리 관련 버그 방지에 기반합니다.\n\n\nEasy\n\nRust 언어의 async/await으로 비동기 프로그래밍하기가 쉽습니다.\n또, Standard Library와 같은 naming convention을 따르는 asynchronous 버전의 library를 제공하기 때문에 개발이 용이합니다.\n\n\nFlexible\n\n단순히 multi-threaded runtime만을 제공하는 것이 아닌 경량화를 위한 work-stealing runtime이나 single-threaded runtime 등도 제공합니다.\n\n\n\nTokio를 사용하지 않아야 할 때\n\nParallell programming 이 더 중요할 때\n\nTokio는 IO-bound application을 개발할 때 좀 더 적합합니다.\n단순히 병렬 프로그래밍이 중요할 때에는 raryon을 사용하는 것이 좋습니다.\n당연히 이 둘을 적절히 섞어가며 사용해도 좋습니다.\n\n\n단순히 File Read작업이 많은 경우에, Tokio를 사용하는 것이 그다지 효용이 없습니다.\nsingle web request 를 다루는 경우에도 큰 이점은 없습니다. 이러한 경우는 blocking API를 사용해도 됩니다.\n\n"},"Notes/zk-regex-analysis":{"title":"zk-Regex 분석","links":[],"tags":[],"content":""},"index":{"title":"Welcome to Quartz","links":["2.1-Groups","2.2-Finite-Fields","2.3-Polynomials-over-Galois-Field-GF(2)"],"tags":[],"content":"Since 2024…\n\n2.1 Groups\n2.2 Finite Fields\n2.3 Polynomials over Galois Field GF(2)"},"Notes/Tokio_2":{"title":"Tokio_2","links":[],"tags":["Rust","Tokio"],"content":"Tutorial\n본 튜토리얼에서는 Tokio를 이용하여, 데이터베이스로 동작하는 Redis의 client와 server를 다뤄봅니다.\n이 과정에서 asynchronous programming의 기초를 이해할 수 있고, Tokio에 대한 이해도도 높일 수 있습니다.\nSetup\n튜토리얼은 Mini-Redis 라는 Tokio 학습용 crate를 이용해 진행됩니다.\n\nMini-Redis\nMini-Redis는 아래와 같이 설치할 수 있습니다.\ncargo install mini-redis\n\n그리고 Server와 Client는 각각 아래 그림과 같이 다룰 수 있습니다.\n\n\nHello Tokio\n이번에는 아주 기초적인 Tokio Application을 만들어봅니다.\nMini-Redis Server에 연결되는 프로그램이며 아래와 같은 동작을 수행합니다.\n\nhello 라는 Key로 World라는 Value를 저장함.\nhello Key로 정보를 read 해봄\n이 과정은 Mini-Redis의 Client library를 사용합니다.\n\nThe code\n우선 아래와 같이 새로운 cargo 프로젝트를 생성합니다.\ncargo new my-redis\ncd my-redis\n\n그리고 아래를 입력해 Cargo.toml 파일을 수정합니다.\necho &#039;tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }\nmini-redis = &quot;0.4&quot;&#039; &gt;&gt; Cargo.toml\n\n그리고 아래와 같이 src/main.rs를 수정합니다.\nuse mini_redis::{client, Result};\n \n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    // Open a connection to the mini-redis address.\n    let mut client = client::connect(&quot;127.0.0.1:6379&quot;).await?;\n \n    // Set the key &quot;hello&quot; with value &quot;world&quot;\n    client.set(&quot;hello&quot;, &quot;world&quot;.into()).await?;\n \n    // Get key &quot;hello&quot;\n    let result = client.get(&quot;hello&quot;).await?;\n \n    println!(&quot;got value from the server; result={:?}&quot;, result);\n \n    Ok(())\n}\n\n당연한 말이지만 Mini-Redis Server가 돌아가고 있어야 합니다.\n\n이제 아래와 같이 실행해보면 결과를 확인할 수 있습니다.\ncargo run\n\n\nBreaking it down\n이제 코드를 하나씩 분석해보겠습니다.\nlet mut client = client::connect(&quot;127.0.0.1:6379&quot;).await?;\nclient::connect 함수는 mini-redis crate에서 왔습니다. 이는 asynchronous하게 TCP연결을 만드는데, 연결이 완료되면 반환값으로 client handle이 반환됩니다. 코드 자체만 놓고 보면 synchronous하게 코딩할 때와 같지만, await 을 사용한다는 점이 다릅니다.\n\n\n                  \n                  asynchronous programming 이란? \n                  \n                \n\n대부분의 컴퓨터 프로그램들은 작성된 순서대로 코드를 따라 실행 됩니다.\n첫 번째 줄이 실행되고 나면, 그 다음 줄이 실행되고 이것이 반복되는 식입니다. 따라서, 이렇게 synchronous한 프로그램들은 중간에 “연산 시간이 오래 걸리는” 코드를 만나게 되면 해당 연산이 끝날 때까지 실행 흐름이 Block됩니다.\n예를 들어, TCP 연결은 3-way handshake 등과 같이 각 peer가 network상에서 정보를 주고 받는 시간이 필요합니다. 이 때 thread가 block되는 것입니다.\nasynchronous 프로그램에서는 이렇게 “오래 걸리는” 코드가 background로 suspended됩니다.\n즉, Thread가 Block되는 것이 아니라 다른 코드들을 실행하는 것입니다.\nbackground로 넘어갔던 코드는 실행이 완료되면 unsuspended되고 실행을 재개합니다.\nasynchronous하게 프로그래밍을하면 더 빠른 프로그램 개발이 가능합니다. 하지만, 프로그래머는 비동기 프로그램의 실행이 완료되었을 때의 상태 추적을 잘 할 필요가 있습니다. 역사적으로, 이 부분은 매우 지루하고 또 에러가 발생하기 쉬운 프로그래밍이라고 합니다.\n\n\nCompile-time green-threading\nRust 언어는 asynchronous programming을 async/await 를 이용해 구현합니다. 비동기로 동작하는 함수는 앞에 async만 붙여주면 됩니다. 위 예제 코드에서 사용한 client::connect()함수는 아래와 같이 정의되어 있습니다.\nuse mini_redis::Result;\nuse mini_redis::client::Client;\nuse tokio::net::ToSocketAddrs;\n \npub async fn connect&lt;T: ToSocketAddrs&gt;(addr: T) -&gt; Result&lt;Client&gt; {\n\t// ... \n}\nasync fn 으로 정의된 비동기 함수는 synchronous 함수와 크게 다르지 않아 보입니다. Rust는 compile time에 asycn fn 함수들을 asynchronous하게 동작하는 routine으로 변환합니다.\nasync fn 함수 안에서 .await 이 일어나면, 현재 Thread에 제어권을 넘기게 됩니다. Thread는 연산이 background에서 일어나도록 두고, 다른 작업을 진행하게 되는 것입니다.\n\n\n                  \n                  Important\n                  \n                \n\nRust 외의 다른 언어들도 async/await라는 이름으로 비동기 프로그래밍을 구현하긴 했으나, Rust는 lazy한 방식으로 이를 구현했다고 합니다.\n\n\nUsing async/await\nasync fn은 다른 Rust함수들 처럼 호출되지만, 호출되었을 때 바로 함수 body를 실행하는 것이 아닙니다.\n그 대신에, async fn은 해당 operation을 대표하는 어떤 value를 반환합니다.\n이는 개념적으로 zero-argument closure와 유사합니다.\n실제로 operation을 실행하려면 .await을 명시해야 합니다.\n아래 코드를 통해 이를 이해할 수 있습니다.\nasync fn say_world() {\n    println!(&quot;world&quot;);\n}\n \n#[tokio::main]\nasync fn main() {\n    // Calling `say_world()` does not execute the body of `say_world()`.\n    let op = say_world();\n \n    // This println! comes first\n    println!(&quot;hello&quot;);\n \n    // Calling `.await` on `op` starts executing `say_world`.\n    op.await;\n}\n위 코드의 실행 결과는 아래와 같습니다.\nhello\nworld\n참고로, async fn함수의 return value는 Future trait을 구현한 임의의 타입이면 됩니다.\n\nasync main function\nasync fn은 함수가 비동기적 맥락에서 수행되기를 원할 때 사용됩니다. 하지만, 비동기 함수는 runtime 에 의해 실행되어야 합니다.\nruntime은 asynchronous task scheduler를 포함하고 evented I/O, timers 등의 기능을 제공합니다. runtime은 자동으로 시작되지 않기 때문에 main함수가 이를 직접 시작해야 합니다.\n#[tokio::main] 함수는 매크로 입니다. 이는 async fn main()으로 명시된 함수를 synchronous인 fn main()으로 변환합니다. 변환된 fn main()함수는 runtime instance를 초기화하고 async main function을 실행합니다.\n예를 들어, 아래와 같이 #[tokio::main]과 async fn main()을 이용해 만든 코드가 있다고 해보겠습니다.\n#[tokio::main]\nasync fn main() {\n\tprintln!(&quot;hello&quot;);\n}\n매크로에 의해 변환된 결과는 아래와 같습니다.\nfn main() {\n\tlet mut runtime = tokio::runtime::Runtime::new().unwrap();\n\trt.block_on(async {\n\t\tprintln!(&quot;hello&quot;);\n\t})\n}\n\n\n                  \n                  Cargo features \n                  \n                \n\nTokio로부터 사용할 기능(feature)를 cargo.toml에 명시할 수 있습니다.\n컴파일타임 등을 최적화하기 위해서는 필요한 기능만 추가하면 됩니다.\n\n"},"Notes/Tokio_3":{"title":"Tokio_3","links":[],"tags":["Rust","Tokio"],"content":"Spawning\n앞선 튜토리얼은 이를테면 client side의 프로그램을 만들어 보는 과정이었습니다.\n여기서는 server를 만드는 과정을 살펴봅니다.\nAccepting Sockets\nServer를 만드는 가장 첫 단계는 inbound TCP socket을 accept하도록 코드를 짜는 것입니다. 이는 tokio::net::TcpListener를 6379번 포트로 binding하여 구현할 수 있습니다. 코드로 완성해보면 아래와 같습니다.\nuse tokio::net::{TcpListener, TcpStream};\nuse mini_redis::{Connection, Frame};\n \n#[tokio::main]\nasync fn main() {\n    // Bind the listener to the address\n    let listener = TcpListener::bind(&quot;127.0.0.1:6379&quot;).await.unwrap();\n \n    loop {\n        // The second item contains the IP and port of the new connection.\n        let (socket, _) = listener.accept().await.unwrap();\n        process(socket).await;\n    }\n}\n \nasync fn process(socket: TcpStream) {\n    // The `Connection` lets us read/write redis **frames** instead of\n    // byte streams. The `Connection` type is defined by mini-redis.\n    let mut connection = Connection::new(socket);\n \n    if let Some(frame) = connection.read_frame().await.unwrap() {\n        println!(&quot;GOT: {:?}&quot;, frame);\n \n        // Respond with an error\n        let response = Frame::Error(&quot;unimplemented&quot;.to_string());\n        connection.write_frame(&amp;response).await.unwrap();\n    }\n}\n이를 실행해보면 아래와 같습니다.\n\nConcurrency\n위 코드의 loop { ... }를 보면 바로 알겠지만, 지금은 하나의 요청을 처리해야 다음 요청을 처리할 수 있습니다.\n만약, 요청 처리 과정이 복잡하거나 시간이 오래 걸린다면 blocking 돼버리는 상황을 생각할 수도 있습니다.\n따라서, 많은 요청을 동시에(concurrently) 처리할 수 있도록 코드를 수정할 필요가 있습니다.\n[!Note]\nConcurrency와 Parallelism은 서로 같은 것이 아닙니다.\n예를 들어, 두 작업 A, B을 번갈아가며 수행하면 concurrent한 것이지 parallel한 것은 아닙니다. parallel하려면 작업 A,B를 수행하는 각각의 일꾼 W_A, W_B가 있어야 합니다.\nTokio를 사용할 때의 장점은 parallel을 걱정할 필요 없이, 심지어 single thread에서도 concurrent한 프로그래밍을 할 수 있다는 점입니다.\nConcurrency를 위해 새로운 Task를 spawn하여 각각의 inbound request를 처리하도록 코드를 수정합니다.\nuse tokio::net::TcpListener;\n \n#[tokio::main]\nasync fn main() {\n    let listener = TcpListener::bind(&quot;127.0.0.1:6379&quot;).await.unwrap();\n \n    loop {\n        let (socket, _) = listener.accept().await.unwrap();\n        // A new task is spawned for each inbound socket. The socket is\n        // moved to the new task and processed there.\n        tokio::spawn(async move {\n            process(socket).await;\n        });\n    }\n}\n \nTasks\nTokio의 Task는 asynchronous한 green thread입니다."}}